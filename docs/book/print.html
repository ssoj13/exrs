<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>EXRS - Rust OpenEXR Library</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the exrs crate - 100% safe Rust implementation of OpenEXR">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex-23e83f04.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-c717cc96.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">EXRS - Rust OpenEXR Library</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/johannesvollmer/exrs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="exrs---rust-openexr-library"><a class="header" href="#exrs---rust-openexr-library">EXRS - Rust OpenEXR Library</a></h1>
<p><strong>exrs</strong> is a 100% Rust, 100% safe code library for reading and writing OpenEXR images.</p>
<p><a href="https://crates.io/crates/exr"><img src="https://img.shields.io/crates/v/exr.svg" alt="Crates.io"></a>
<a href="https://docs.rs/exr"><img src="https://docs.rs/exr/badge.svg" alt="Docs.rs"></a></p>
<h2 id="what-is-this-library"><a class="header" href="#what-is-this-library">What is this library?</a></h2>
<p>This library provides a pure Rust implementation of the OpenEXR image format, the de-facto standard in animation, VFX, and computer graphics pipelines. Unlike bindings to the C++ reference implementation, exrs:</p>
<ul>
<li>Uses <strong>no unsafe code</strong> (<code>#[forbid(unsafe_code)]</code>)</li>
<li>Requires <strong>no CMake</strong> or external dependencies</li>
<li>Works on <strong>WebAssembly</strong> out of the box</li>
<li>Provides a <strong>modern, ergonomic Rust API</strong></li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Multi-layer images</strong> - Any number of layers placed anywhere in 2D space</li>
<li><strong>Flexible channels</strong> - RGB, RGBA, XYZ, LAB, depth, motion, masks - anything</li>
<li><strong>HDR precision</strong> - 16-bit float, 32-bit float, or 32-bit unsigned integer per channel</li>
<li><strong>Deep data</strong> - Variable samples per pixel for volumetric effects (OpenEXR 2.0)</li>
<li><strong>Compression</strong> - Lossless (ZIP, RLE, PIZ, B44) and lossy options</li>
<li><strong>Multi-resolution</strong> - Mip maps and rip maps support</li>
<li><strong>Parallel processing</strong> - Compress/decompress on multiple threads</li>
<li><strong>Custom metadata</strong> - Arbitrary attributes with full backwards compatibility</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
exr = "1.74.0"
</code></pre>
<p>For optimal performance:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() {
    // Write a simple RGBA image
    write_rgba_file(
        "output.exr",
        1920, 1080,
        |x, y| {
            let r = x as f32 / 1920.0;
            let g = y as f32 / 1080.0;
            let b = 0.5;
            let a = 1.0;
            (r, g, b, a)
        }
    ).unwrap();
    
    // Read it back
    let image = read_first_rgba_layer_from_file(
        "output.exr",
        |resolution, _| vec![(0.0f32, 0.0, 0.0, 0.0); resolution.width() * resolution.height()],
        |pixels, pos, (r, g, b, a): (f32, f32, f32, f32)| {
            pixels[pos.y() * pos.width() + pos.x()] = (r, g, b, a);
        }
    ).unwrap();
}</code></pre>
<h2 id="documentation-structure"><a class="header" href="#documentation-structure">Documentation Structure</a></h2>
<p>This documentation is organized into three main sections:</p>
<ol>
<li><strong><a href="#what-is-openexr">User Guide</a></strong> - Learn about EXR format, basic usage, and our enhancements</li>
<li><strong><a href="#architecture-overview">Developer Guide</a></strong> - Understand the library architecture and contribute</li>
<li><strong><a href="#prelude">API Reference</a></strong> - Detailed module and type documentation</li>
</ol>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>BSD-3-Clause</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Contributions are welcome! See the <a href="#contributing-1">Contributing</a> guide.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="what-is-openexr"><a class="header" href="#what-is-openexr">What is OpenEXR?</a></h1>
<p><strong>OpenEXR</strong> is an open-source, high dynamic range (HDR) image file format developed by Industrial Light &amp; Magic (ILM) for use in computer graphics applications.</p>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>OpenEXR was originally developed at ILM in the late 1990s and was released as open source in 2003. Since then, it has become the industry standard for visual effects, animation, and film production.</p>
<p>Key milestones:</p>
<ul>
<li><strong>1999</strong> - Internal development at ILM</li>
<li><strong>2003</strong> - Open source release (v1.0)</li>
<li><strong>2013</strong> - OpenEXR 2.0 with deep data support</li>
<li><strong>2020</strong> - Moved to Academy Software Foundation (ASWF)</li>
</ul>
<h2 id="format-overview"><a class="header" href="#format-overview">Format Overview</a></h2>
<p>An OpenEXR file consists of:</p>
<pre><code>+---------------------------+
|      Magic Number         |  4 bytes: 0x762f3101
+---------------------------+
|    Version + Flags        |  4 bytes
+---------------------------+
|         Headers           |  Attributes as key-value pairs
+---------------------------+
|      Offset Tables        |  Pointers to pixel data chunks
+---------------------------+
|       Pixel Data          |  Compressed/uncompressed chunks
+---------------------------+
</code></pre>
<h3 id="file-types"><a class="header" href="#file-types">File Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>Scanline</strong></td><td>Row-by-row storage</td><td>General images</td></tr>
<tr><td><strong>Tiled</strong></td><td>Block-based storage</td><td>Large images, streaming</td></tr>
<tr><td><strong>Multi-part</strong></td><td>Multiple independent images</td><td>Layered compositing</td></tr>
<tr><td><strong>Deep</strong></td><td>Variable samples per pixel</td><td>Volumetrics, particles</td></tr>
</tbody>
</table>
</div>
<h2 id="why-exr"><a class="header" href="#why-exr">Why “EXR”?</a></h2>
<p>The name comes from the file extension <code>.exr</code>. The library was named “IlmImf” internally (ILM Image Format), but the format became known by its extension.</p>
<h2 id="key-technical-features"><a class="header" href="#key-technical-features">Key Technical Features</a></h2>
<h3 id="high-dynamic-range"><a class="header" href="#high-dynamic-range">High Dynamic Range</a></h3>
<p>Unlike 8-bit formats (PNG, JPEG), EXR stores actual light values:</p>
<pre><code>8-bit:  0-255 (256 values)
16-bit float: 6x10^-8 to 6.5x10^4 (dynamic range ~10^9)
32-bit float: Full IEEE 754 range
</code></pre>
<p>This preserves:</p>
<ul>
<li>Highlights that would clip in LDR formats</li>
<li>Shadow detail</li>
<li>Physical light ratios for accurate compositing</li>
</ul>
<h3 id="pixel-types"><a class="header" href="#pixel-types">Pixel Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Size</th><th>Range</th><th>Precision</th></tr>
</thead>
<tbody>
<tr><td><code>half</code> (f16)</td><td>16-bit</td><td>~6e-8 to 65504</td><td>3 decimal digits</td></tr>
<tr><td><code>float</code> (f32)</td><td>32-bit</td><td>Full IEEE 754</td><td>7 decimal digits</td></tr>
<tr><td><code>uint</code> (u32)</td><td>32-bit</td><td>0 to 4,294,967,295</td><td>Exact integers</td></tr>
</tbody>
</table>
</div>
<h3 id="arbitrary-channels"><a class="header" href="#arbitrary-channels">Arbitrary Channels</a></h3>
<p>Unlike fixed RGB/RGBA formats, EXR supports any channels:</p>
<pre><code>Standard:    R, G, B, A
Extended:    R, G, B, A, Z (depth), N.x, N.y, N.z (normals)
VFX:         R, G, B, A, Z, ZBack, motion.u, motion.v, crypto_object
Custom:      Any name you need
</code></pre>
<h3 id="compression-methods"><a class="header" href="#compression-methods">Compression Methods</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Type</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td>None</td><td>Uncompressed</td><td>Maximum speed</td></tr>
<tr><td>RLE</td><td>Lossless</td><td>Simple patterns</td></tr>
<tr><td>ZIP</td><td>Lossless</td><td>General use</td></tr>
<tr><td>ZIPS</td><td>Lossless</td><td>Single scanlines</td></tr>
<tr><td>PIZ</td><td>Lossless</td><td>Noisy images</td></tr>
<tr><td>PXR24</td><td>Lossy (f32→f24)</td><td>Large float images</td></tr>
<tr><td>B44/B44A</td><td>Lossy</td><td>Real-time playback</td></tr>
<tr><td>DWAA/DWAB</td><td>Lossy</td><td>Smallest files</td></tr>
</tbody>
</table>
</div>
<h3 id="layers-multi-part"><a class="header" href="#layers-multi-part">Layers (Multi-Part)</a></h3>
<p>EXR can contain multiple independent images:</p>
<pre><code>my_render.exr
├── beauty (main RGBA)
├── diffuse (RGB)
├── specular (RGB)
├── reflection (RGB)
├── shadow (A)
├── depth (Z)
└── motion (UV)
</code></pre>
<h3 id="resolution-levels"><a class="header" href="#resolution-levels">Resolution Levels</a></h3>
<p><strong>Mip Maps</strong> - Power-of-2 downscaled versions:</p>
<pre><code>Level 0: 4096 x 2048
Level 1: 2048 x 1024
Level 2: 1024 x 512
...
</code></pre>
<p><strong>Rip Maps</strong> - Independent X/Y scaling:</p>
<pre><code>Level (0,0): 4096 x 2048
Level (1,0): 2048 x 2048
Level (0,1): 4096 x 1024
Level (1,1): 2048 x 1024
...
</code></pre>
<h2 id="deep-data-openexr-20"><a class="header" href="#deep-data-openexr-20">Deep Data (OpenEXR 2.0)</a></h2>
<p>Traditional (flat) images store one sample per pixel. Deep images store <strong>variable samples per pixel</strong>:</p>
<pre><code>Flat image:
  Pixel (10, 20) = RGBA(0.5, 0.3, 0.1, 1.0)

Deep image:
  Pixel (10, 20) = [
    {Z=1.5, RGBA(0.2, 0.1, 0.0, 0.3)},  // Smoke at depth 1.5
    {Z=5.0, RGBA(0.8, 0.6, 0.4, 1.0)},  // Object at depth 5.0
    {Z=8.2, RGBA(0.1, 0.1, 0.1, 0.1)},  // More smoke at depth 8.2
  ]
</code></pre>
<p>Use cases:</p>
<ul>
<li>Volumetric rendering (smoke, fog, clouds)</li>
<li>Particle systems</li>
<li>Hair/fur with transparency</li>
<li>Deep compositing without artifacts</li>
</ul>
<h2 id="metadata-attributes"><a class="header" href="#metadata-attributes">Metadata (Attributes)</a></h2>
<p>EXR supports extensive metadata:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>displayWindow</code></td><td>Box2i</td><td>Full frame dimensions</td></tr>
<tr><td><code>dataWindow</code></td><td>Box2i</td><td>Actual pixel bounds</td></tr>
<tr><td><code>pixelAspectRatio</code></td><td>float</td><td>Pixel shape</td></tr>
<tr><td><code>chromaticities</code></td><td>Chromaticities</td><td>Color space primaries</td></tr>
<tr><td><code>whiteLuminance</code></td><td>float</td><td>Absolute brightness</td></tr>
<tr><td><code>timeCode</code></td><td>TimeCode</td><td>SMPTE timecode</td></tr>
<tr><td><code>framesPerSecond</code></td><td>Rational</td><td>Frame rate</td></tr>
<tr><td><code>owner</code></td><td>string</td><td>Copyright holder</td></tr>
<tr><td>Custom</td><td>Any</td><td>Your own attributes</td></tr>
</tbody>
</table>
</div>
<h2 id="industry-usage"><a class="header" href="#industry-usage">Industry Usage</a></h2>
<p>OpenEXR is used in virtually every major VFX and animation production:</p>
<ul>
<li><strong>Film</strong>: Avatar, Avengers, Star Wars, Marvel films</li>
<li><strong>Animation</strong>: Pixar, DreamWorks, Disney, Sony Animation</li>
<li><strong>Games</strong>: Asset pipelines, HDR textures</li>
<li><strong>Software</strong>: Nuke, Maya, Houdini, Blender, After Effects, DaVinci Resolve</li>
</ul>
<h2 id="comparison-with-other-formats"><a class="header" href="#comparison-with-other-formats">Comparison with Other Formats</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>EXR</th><th>PNG</th><th>TIFF</th><th>HDR</th></tr>
</thead>
<tbody>
<tr><td>HDR</td><td>Yes</td><td>No</td><td>Limited</td><td>Yes</td></tr>
<tr><td>Bit Depth</td><td>16/32 float</td><td>8/16 int</td><td>8/16/32</td><td>32 float</td></tr>
<tr><td>Layers</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td>Deep Data</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td>Compression</td><td>Multiple</td><td>Lossless</td><td>Multiple</td><td>RLE</td></tr>
<tr><td>Metadata</td><td>Extensive</td><td>Limited</td><td>Good</td><td>Minimal</td></tr>
<tr><td>Color Spaces</td><td>Any</td><td>sRGB</td><td>Various</td><td>Linear</td></tr>
</tbody>
</table>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#why-use-exr">Why Use EXR?</a> - Benefits for your workflow</li>
<li><a href="#quick-start">Quick Start</a> - Start reading and writing EXR files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="why-use-exr"><a class="header" href="#why-use-exr">Why Use EXR?</a></h1>
<p>OpenEXR solves real problems in professional graphics pipelines. Here’s why you should consider it.</p>
<h2 id="high-dynamic-range-preservation"><a class="header" href="#high-dynamic-range-preservation">High Dynamic Range Preservation</a></h2>
<h3 id="the-problem-with-8-bit"><a class="header" href="#the-problem-with-8-bit">The Problem with 8-bit</a></h3>
<p>Standard 8-bit images (PNG, JPEG) can only represent 256 brightness levels. Real-world scenes have much greater range:</p>
<pre><code>Sunlight:     ~100,000 lux
Indoor light: ~500 lux
Moonlight:    ~0.1 lux
</code></pre>
<p>That’s a range of 1,000,000:1 - impossible to capture in 256 values.</p>
<h3 id="exr-solution"><a class="header" href="#exr-solution">EXR Solution</a></h3>
<p>EXR’s floating-point storage preserves the full dynamic range:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// Store actual physical light values
write_rgba_file("hdr_scene.exr", 1920, 1080, |x, y| {
    let sun = 100000.0_f32;      // Direct sunlight
    let sky = 10000.0_f32;       // Sky brightness  
    let shadow = 100.0_f32;      // Deep shadow
    
    // All values preserved exactly
    (sun, sky, shadow, 1.0)
}).unwrap();
<span class="boring">}</span></code></pre>
<p>Benefits:</p>
<ul>
<li><strong>No clipping</strong> - Highlights preserved for later adjustment</li>
<li><strong>No banding</strong> - Smooth gradients in shadows</li>
<li><strong>Accurate compositing</strong> - Correct light addition/multiplication</li>
</ul>
<h2 id="lossless-workflow"><a class="header" href="#lossless-workflow">Lossless Workflow</a></h2>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<p>Every save in lossy formats (JPEG) degrades quality. Even “high quality” settings accumulate artifacts through a pipeline.</p>
<h3 id="exr-solution-1"><a class="header" href="#exr-solution-1">EXR Solution</a></h3>
<p>Most EXR compression is lossless:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let layer = Layer::new(
    (1920, 1080),
    LayerAttributes::named("main"),
    Encoding {
        compression: Compression::ZIP16,  // Lossless, good compression
        ..Default::default()
    },
    channels
);
<span class="boring">}</span></code></pre>
<p>Your pixels are mathematically identical after decompression.</p>
<h2 id="flexible-channel-support"><a class="header" href="#flexible-channel-support">Flexible Channel Support</a></h2>
<h3 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h3>
<p>Fixed formats force you into RGB or RGBA. What about:</p>
<ul>
<li>Depth (Z) for depth of field?</li>
<li>Normals (N.xyz) for relighting?</li>
<li>Motion vectors (motion.uv) for motion blur?</li>
<li>Cryptomatte IDs for selection?</li>
</ul>
<h3 id="exr-solution-2"><a class="header" href="#exr-solution-2">EXR Solution</a></h3>
<p>Add any channels you need:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let channels = AnyChannels::sort(smallvec![
    AnyChannel::new("R", FlatSamples::F16(red_data)),
    AnyChannel::new("G", FlatSamples::F16(green_data)),
    AnyChannel::new("B", FlatSamples::F16(blue_data)),
    AnyChannel::new("A", FlatSamples::F16(alpha_data)),
    AnyChannel::new("Z", FlatSamples::F32(depth_data)),
    AnyChannel::new("N.x", FlatSamples::F16(normal_x)),
    AnyChannel::new("N.y", FlatSamples::F16(normal_y)),
    AnyChannel::new("N.z", FlatSamples::F16(normal_z)),
    AnyChannel::new("motion.u", FlatSamples::F16(motion_u)),
    AnyChannel::new("motion.v", FlatSamples::F16(motion_v)),
]);
<span class="boring">}</span></code></pre>
<h2 id="multi-layer-storage"><a class="header" href="#multi-layer-storage">Multi-Layer Storage</a></h2>
<h3 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h3>
<p>Render passes typically create dozens of files:</p>
<ul>
<li><code>render_beauty.png</code></li>
<li><code>render_diffuse.png</code></li>
<li><code>render_specular.png</code></li>
<li>…and 20 more</li>
</ul>
<p>Managing versions, frame numbers, and synchronization is painful.</p>
<h3 id="exr-solution-3"><a class="header" href="#exr-solution-3">EXR Solution</a></h3>
<p>One file, all passes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let image = Image::empty(ImageAttributes::new(IntegerBounds::from_dimensions((1920, 1080))))
    .with_layer(beauty_layer)
    .with_layer(diffuse_layer)
    .with_layer(specular_layer)
    .with_layer(depth_layer);

image.write().to_file("render_0001.exr").unwrap();
<span class="boring">}</span></code></pre>
<p>Benefits:</p>
<ul>
<li>Atomic saves - all passes or none</li>
<li>Single version number</li>
<li>Guaranteed synchronization</li>
<li>Easier file management</li>
</ul>
<h2 id="arbitrary-metadata"><a class="header" href="#arbitrary-metadata">Arbitrary Metadata</a></h2>
<h3 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h3>
<p>You need to store:</p>
<ul>
<li>Camera settings (focal length, f-stop)</li>
<li>Render settings (samples, time)</li>
<li>Color space information</li>
<li>Custom production data</li>
</ul>
<p>Most formats have limited or no metadata support.</p>
<h3 id="exr-solution-4"><a class="header" href="#exr-solution-4">EXR Solution</a></h3>
<p>EXR supports extensive built-in and custom attributes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let mut attrs = LayerAttributes::named("main");

// Built-in attributes
attrs.owner = Some(Text::from("Studio XYZ"));
attrs.comments = Some(Text::from("Final render v3"));
attrs.software_name = Some(Text::from("Custom Renderer 2.0"));

// Custom attributes
attrs.other.insert(
    Text::from("renderTime"),
    AttributeValue::F32(3600.5)  // 1 hour render
);
attrs.other.insert(
    Text::from("samples"),
    AttributeValue::I32(4096)
);
<span class="boring">}</span></code></pre>
<h2 id="efficient-compression"><a class="header" href="#efficient-compression">Efficient Compression</a></h2>
<h3 id="compression-comparison"><a class="header" href="#compression-comparison">Compression Comparison</a></h3>
<p>For a typical VFX frame (1920x1080, RGBA float):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Compression</th><th>Size</th><th>Quality</th></tr>
</thead>
<tbody>
<tr><td>Uncompressed</td><td>None</td><td>32 MB</td><td>Perfect</td></tr>
<tr><td>EXR ZIP</td><td>Lossless</td><td>8-15 MB</td><td>Perfect</td></tr>
<tr><td>EXR PIZ</td><td>Lossless</td><td>6-12 MB</td><td>Perfect</td></tr>
<tr><td>EXR B44</td><td>Lossy</td><td>4-8 MB</td><td>Excellent</td></tr>
<tr><td>PNG 16-bit</td><td>Lossless</td><td>12-20 MB</td><td>LDR only</td></tr>
<tr><td>JPEG</td><td>Lossy</td><td>0.5-2 MB</td><td>Artifacts</td></tr>
</tbody>
</table>
</div>
<h3 id="choosing-compression"><a class="header" href="#choosing-compression">Choosing Compression</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// Fast read/write, larger files
Compression::Uncompressed

// Good balance (recommended default)
Compression::ZIP16

// Best for noisy/film grain images
Compression::PIZ

// Fastest compression, single scanlines
Compression::ZIPS

// Lossy but fast decompression (playback)
Compression::B44
<span class="boring">}</span></code></pre>
<h2 id="deep-data-for-vfx"><a class="header" href="#deep-data-for-vfx">Deep Data for VFX</a></h2>
<h3 id="the-problem-4"><a class="header" href="#the-problem-4">The Problem</a></h3>
<p>Traditional compositing with pre-multiplied alpha causes artifacts:</p>
<ul>
<li>Edge fringing when backgrounds change</li>
<li>Incorrect transparency stacking</li>
<li>Loss of depth information</li>
</ul>
<h3 id="exr-deep-data-solution"><a class="header" href="#exr-deep-data-solution">EXR Deep Data Solution</a></h3>
<p>Store full depth information per pixel:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::image::read::deep::read_first_deep_layer_from_file;

let deep_image = read_first_deep_layer_from_file("particles.exr").unwrap();

// Each pixel can have 0 to thousands of samples
for y in 0..height {
    for x in 0..width {
        let count = samples.sample_count(x, y);
        // Process each depth sample
    }
}
<span class="boring">}</span></code></pre>
<p>Benefits:</p>
<ul>
<li>Correct transparency at any depth</li>
<li>Re-composite with different backgrounds</li>
<li>Merge volumetric elements properly</li>
</ul>
<h2 id="industry-compatibility"><a class="header" href="#industry-compatibility">Industry Compatibility</a></h2>
<h3 id="supported-software"><a class="header" href="#supported-software">Supported Software</a></h3>
<p>EXR is read/written by virtually all professional tools:</p>
<p><strong>Compositing:</strong></p>
<ul>
<li>Nuke</li>
<li>After Effects</li>
<li>Fusion</li>
<li>Natron</li>
</ul>
<p><strong>3D/Rendering:</strong></p>
<ul>
<li>Maya</li>
<li>Houdini</li>
<li>Blender</li>
<li>3ds Max</li>
<li>Cinema 4D</li>
<li>Arnold, V-Ray, RenderMan, etc.</li>
</ul>
<p><strong>Image Editing:</strong></p>
<ul>
<li>Photoshop</li>
<li>GIMP</li>
<li>Krita</li>
</ul>
<p><strong>Color Grading:</strong></p>
<ul>
<li>DaVinci Resolve</li>
<li>Baselight</li>
</ul>
<h3 id="pipeline-integration"><a class="header" href="#pipeline-integration">Pipeline Integration</a></h3>
<p>EXR is often the <em>only</em> format that can pass through an entire pipeline without data loss:</p>
<pre><code>Render (HDR) → Composite → Color Grade → Final Output
     ↓              ↓            ↓
    EXR            EXR          EXR → Delivery format
</code></pre>
<h2 id="why-exrs-specifically"><a class="header" href="#why-exrs-specifically">Why exrs Specifically?</a></h2>
<p>This Rust library offers advantages over C++ bindings:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>exrs</th><th>C++ Bindings</th></tr>
</thead>
<tbody>
<tr><td>Safety</td><td><code>#[forbid(unsafe_code)]</code></td><td>Inherits C++ issues</td></tr>
<tr><td>Build</td><td><code>cargo add exr</code></td><td>CMake, env vars</td></tr>
<tr><td>WASM</td><td>Works</td><td>Difficult</td></tr>
<tr><td>API</td><td>Modern Rust idioms</td><td>C++ style</td></tr>
<tr><td>Dependencies</td><td>Pure Rust</td><td>libexr, zlib, etc.</td></tr>
</tbody>
</table>
</div>
<h2 id="when-not-to-use-exr"><a class="header" href="#when-not-to-use-exr">When NOT to Use EXR</a></h2>
<p>EXR isn’t always the right choice:</p>
<ul>
<li><strong>Web delivery</strong> - Use JPEG, WebP, AVIF</li>
<li><strong>Simple screenshots</strong> - PNG is simpler</li>
<li><strong>Video</strong> - Use video codecs (ProRes, DNxHR)</li>
<li><strong>Texture streaming</strong> - Use GPU-native formats (BC, ASTC)</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Use EXR when you need:</p>
<ul>
<li>HDR data preservation</li>
<li>Lossless quality</li>
<li>Multiple channels/layers</li>
<li>Rich metadata</li>
<li>VFX pipeline compatibility</li>
<li>Deep compositing</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="#quick-start">Quick Start</a> - Begin using exrs</li>
<li><a href="#reading-images">Reading Images</a> - Load EXR files</li>
<li><a href="#writing-images">Writing Images</a> - Create EXR files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Get up and running with exrs in minutes.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Add exrs to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
exr = "1.74.0"
</code></pre>
<p>For best performance, enable link-time optimization:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<h2 id="the-prelude"><a class="header" href="#the-prelude">The Prelude</a></h2>
<p>Import the prelude for convenient access to common types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;
<span class="boring">}</span></code></pre>
<p>This includes:</p>
<ul>
<li><code>read()</code>, <code>write_rgba_file()</code>, etc.</li>
<li><code>Image</code>, <code>Layer</code>, <code>Encoding</code></li>
<li><code>f16</code>, <code>Vec2</code>, <code>Text</code></li>
<li><code>Error</code>, <code>Result</code></li>
</ul>
<h2 id="writing-your-first-exr"><a class="header" href="#writing-your-first-exr">Writing Your First EXR</a></h2>
<h3 id="simple-rgba"><a class="header" href="#simple-rgba">Simple RGBA</a></h3>
<p>The easiest way to write an image:</p>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() {
    write_rgba_file(
        "my_first.exr",
        800, 600,  // width, height
        |x, y| {
            // Return (R, G, B, A) for each pixel
            let r = x as f32 / 800.0;
            let g = y as f32 / 600.0;
            let b = 0.5_f32;
            let a = 1.0_f32;
            (r, g, b, a)
        }
    ).expect("Failed to write EXR");
    
    println!("Created my_first.exr");
}</code></pre>
<h3 id="rgb-without-alpha"><a class="header" href="#rgb-without-alpha">RGB Without Alpha</a></h3>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() {
    write_rgb_file(
        "rgb_only.exr",
        1920, 1080,
        |x, y| {
            (0.2_f32, 0.4_f32, 0.6_f32)
        }
    ).unwrap();
}</code></pre>
<h2 id="reading-your-first-exr"><a class="header" href="#reading-your-first-exr">Reading Your First EXR</a></h2>
<h3 id="read-rgba"><a class="header" href="#read-rgba">Read RGBA</a></h3>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() {
    let image = read_first_rgba_layer_from_file(
        "my_first.exr",
        
        // Constructor: create your pixel storage
        |resolution, _channels| {
            vec![(0.0_f32, 0.0, 0.0, 1.0); resolution.width() * resolution.height()]
        },
        
        // Setter: store each pixel
        |pixels, position, (r, g, b, a): (f32, f32, f32, f32)| {
            let index = position.y() * position.width() + position.x();
            pixels[index] = (r, g, b, a);
        }
    ).expect("Failed to read EXR");
    
    println!("Loaded image: {}x{}", 
        image.layer_data.size.0, 
        image.layer_data.size.1
    );
}</code></pre>
<h3 id="read-all-data-dynamic"><a class="header" href="#read-all-data-dynamic">Read All Data (Dynamic)</a></h3>
<p>When you don’t know what’s in the file:</p>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() {
    let image = read_all_data_from_file("unknown.exr")
        .expect("Failed to read EXR");
    
    println!("Image has {} layers", image.layer_data.len());
    
    for (i, layer) in image.layer_data.iter().enumerate() {
        println!("Layer {}: {} channels, {}x{}", 
            i,
            layer.channel_data.list.len(),
            layer.size.0,
            layer.size.1
        );
        
        for channel in &amp;layer.channel_data.list {
            println!("  - {} ({:?})", 
                channel.name, 
                channel.sample_data.sample_type()
            );
        }
    }
}</code></pre>
<h2 id="working-with-pixel-data"><a class="header" href="#working-with-pixel-data">Working with Pixel Data</a></h2>
<h3 id="from-existing-data"><a class="header" href="#from-existing-data">From Existing Data</a></h3>
<p>If you already have pixel data:</p>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() {
    // Your existing pixel buffer
    let width = 256;
    let height = 256;
    let pixels: Vec&lt;(f32, f32, f32, f32)&gt; = (0..width*height)
        .map(|i| {
            let x = (i % width) as f32 / width as f32;
            let y = (i / width) as f32 / height as f32;
            (x, y, 0.5, 1.0)
        })
        .collect();
    
    // Write using closure that looks up your data
    write_rgba_file(
        "from_buffer.exr",
        width, height,
        |x, y| pixels[y * width + x]
    ).unwrap();
}</code></pre>
<h3 id="using-half-f16"><a class="header" href="#using-half-f16">Using half (f16)</a></h3>
<p>For smaller files, use 16-bit floats:</p>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() {
    write_rgba_file(
        "half_precision.exr",
        1920, 1080,
        |x, y| {
            // Return f16 values for half-precision storage
            (
                f16::from_f32(x as f32 / 1920.0),
                f16::from_f32(y as f32 / 1080.0),
                f16::from_f32(0.5),
                f16::ONE
            )
        }
    ).unwrap();
}</code></pre>
<h2 id="compression-options"><a class="header" href="#compression-options">Compression Options</a></h2>
<h3 id="quick-presets"><a class="header" href="#quick-presets">Quick Presets</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// In Layer construction:
let layer = Layer::new(
    (1920, 1080),
    LayerAttributes::named("main"),
    Encoding::FAST_LOSSLESS,  // ZIP, good balance
    channels
);

// Other presets:
// Encoding::UNCOMPRESSED     - Fastest I/O, largest files
// Encoding::SMALL_LOSSLESS   - PIZ, best compression
// Encoding::SMALL_LOSSY      - B44, smallest lossy
<span class="boring">}</span></code></pre>
<h3 id="custom-compression"><a class="header" href="#custom-compression">Custom Compression</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let encoding = Encoding {
    compression: Compression::ZIP16,  // ZIP with 16-line blocks
    blocks: Blocks::ScanLines,        // Scanline-based
    line_order: LineOrder::Increasing,
};
<span class="boring">}</span></code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>exrs uses a custom <code>Error</code> type:</p>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() {
    match read_all_data_from_file("maybe_missing.exr") {
        Ok(image) =&gt; println!("Loaded successfully"),
        Err(Error::Io(io_err)) =&gt; {
            eprintln!("File error: {}", io_err);
        }
        Err(Error::Invalid(msg)) =&gt; {
            eprintln!("Invalid EXR: {}", msg);
        }
        Err(Error::NotSupported(msg)) =&gt; {
            eprintln!("Unsupported feature: {}", msg);
        }
        Err(e) =&gt; eprintln!("Other error: {:?}", e),
    }
}</code></pre>
<h2 id="parallel-processing"><a class="header" href="#parallel-processing">Parallel Processing</a></h2>
<p>By default, exrs uses all CPU cores for compression/decompression. To disable:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// Reading
let image = read()
    .no_deep_data()
    .largest_resolution_level()
    .all_channels()
    .first_valid_layer()
    .all_attributes()
    .non_parallel()  // Single-threaded
    .from_file("image.exr")
    .unwrap();

// Writing
image.write()
    .non_parallel()  // Single-threaded
    .to_file("output.exr")
    .unwrap();
<span class="boring">}</span></code></pre>
<h2 id="progress-callbacks"><a class="header" href="#progress-callbacks">Progress Callbacks</a></h2>
<p>For large files, track progress:</p>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() {
    // Reading with progress
    let image = read()
        .no_deep_data()
        .largest_resolution_level()
        .all_channels()
        .first_valid_layer()
        .all_attributes()
        .on_progress(|progress| {
            print!("\rReading: {:.1}%", progress * 100.0);
        })
        .from_file("large.exr")
        .unwrap();
    println!("\nDone!");
    
    // Writing with progress
    image.write()
        .on_progress(|progress| {
            print!("\rWriting: {:.1}%", progress * 100.0);
        })
        .to_file("output.exr")
        .unwrap();
    println!("\nDone!");
}</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next?</a></h2>
<ul>
<li><a href="#reading-images">Reading Images</a> - Advanced reading options</li>
<li><a href="#writing-images">Writing Images</a> - Custom layers and channels</li>
<li><a href="#deep-data">Deep Data</a> - Variable samples per pixel</li>
<li><a href="#our-enhancements">Our Enhancements</a> - Extended features</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="reading-images"><a class="header" href="#reading-images">Reading Images</a></h1>
<p>This guide covers all the ways to read EXR files with exrs.</p>
<h2 id="reading-pipeline-overview"><a class="header" href="#reading-pipeline-overview">Reading Pipeline Overview</a></h2>
<p>Reading an EXR file follows a builder pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let image = read()              // Start builder
    .no_deep_data()             // Skip deep data
    .largest_resolution_level() // Only full resolution
    .all_channels()             // Load all channels
    .first_valid_layer()        // First matching layer
    .all_attributes()           // Keep all metadata
    .from_file("image.exr")?;   // Execute
<span class="boring">}</span></code></pre>
<p>Each method refines what data you want, and the final <code>from_file()</code> / <code>from_buffered()</code> executes the read.</p>
<h2 id="convenience-functions"><a class="header" href="#convenience-functions">Convenience Functions</a></h2>
<p>For common cases, use these one-liners:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// RGBA with custom storage
let image = read_first_rgba_layer_from_file(
    "image.exr",
    |res, _| vec![(0f32, 0f32, 0f32, 1f32); res.width() * res.height()],
    |pixels, pos, px| pixels[pos.flat_index()] = px
)?;

// All RGBA layers
let image = read_all_rgba_layers_from_file(
    "multilayer.exr",
    |res, _| vec![(0f32, 0f32, 0f32, 1f32); res.width() * res.height()],
    |pixels, pos, px| pixels[pos.flat_index()] = px
)?;

// First layer, any channels
let image = read_first_flat_layer_from_file("image.exr")?;

// All layers, all channels (most flexible)
let image = read_all_flat_layers_from_file("image.exr")?;

// Everything including metadata
let image = read_all_data_from_file("image.exr")?;
<span class="boring">}</span></code></pre>
<h2 id="deep-vs-flat-data"><a class="header" href="#deep-vs-flat-data">Deep vs Flat Data</a></h2>
<p>The first choice: do you want deep data (variable samples per pixel)?</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// Flat data only (one sample per pixel)
let reader = read().no_deep_data();

// Deep data only
use exr::image::read::deep::read_deep;
let reader = read_deep();

// Either (unified reader)
let image = read_first_any_layer_from_file("unknown.exr")?;
<span class="boring">}</span></code></pre>
<p>See <a href="#deep-data">Deep Data</a> for more on deep images.</p>
<h2 id="resolution-levels-1"><a class="header" href="#resolution-levels-1">Resolution Levels</a></h2>
<p>EXR files may contain mip maps or rip maps:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// Only the largest (full) resolution
let reader = read().no_deep_data().largest_resolution_level();

// All resolution levels
let reader = read().no_deep_data().all_resolution_levels();

// Specific level by index
let reader = read().no_deep_data()
    .specific_resolution_level(|levels| {
        // levels: Vec&lt;LevelInfo&gt; with index and resolution
        Vec2(1, 1)  // Return desired level index
    });

// Level closest to target size
let reader = read().no_deep_data()
    .specific_resolution_level(|levels| {
        let target = 512;
        levels.iter()
            .min_by_key(|l| (l.resolution.x() as i64 - target).abs())
            .map(|l| l.index)
            .unwrap_or(Vec2(0, 0))
    });
<span class="boring">}</span></code></pre>
<h2 id="channel-selection"><a class="header" href="#channel-selection">Channel Selection</a></h2>
<h3 id="all-channels"><a class="header" href="#all-channels">All Channels</a></h3>
<p>Load every channel as a dynamic list:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let reader = read()
    .no_deep_data()
    .largest_resolution_level()
    .all_channels();  // Vec&lt;AnyChannel&gt;
<span class="boring">}</span></code></pre>
<h3 id="rgba-channels"><a class="header" href="#rgba-channels">RGBA Channels</a></h3>
<p>Load specifically R, G, B, A (with A optional):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let image = read()
    .no_deep_data()
    .largest_resolution_level()
    .rgba_channels(
        // Constructor
        |resolution, _channel_info| {
            MyImage::new(resolution.width(), resolution.height())
        },
        // Pixel setter
        |image: &amp;mut MyImage, position, (r, g, b, a): (f32, f32, f32, f32)| {
            image.set_pixel(position.x(), position.y(), r, g, b, a);
        }
    )
    .first_valid_layer()
    .all_attributes()
    .from_file("image.exr")?;
<span class="boring">}</span></code></pre>
<h3 id="rgb-channels"><a class="header" href="#rgb-channels">RGB Channels</a></h3>
<p>Same as RGBA but without alpha:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.rgb_channels(
    |resolution, _| MyImage::new(resolution.width(), resolution.height()),
    |image, pos, (r, g, b): (f32, f32, f32)| {
        image.set_rgb(pos.x(), pos.y(), r, g, b);
    }
)
<span class="boring">}</span></code></pre>
<h3 id="specific-channels-by-name"><a class="header" href="#specific-channels-by-name">Specific Channels by Name</a></h3>
<p>Load exactly the channels you need:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let image = read()
    .no_deep_data()
    .largest_resolution_level()
    .specific_channels()
        .required("R")
        .required("G") 
        .required("B")
        .optional("depth", 1.0_f32)  // Default if missing
        .collect_pixels(
            // Constructor
            |res, _| vec![(0f32, 0f32, 0f32, 0f32); res.width() * res.height()],
            // Setter - tuple matches channel order
            |vec, pos, (r, g, b, depth): (f32, f32, f32, f32)| {
                vec[pos.flat_index()] = (r, g, b, depth);
            }
        )
    .first_valid_layer()
    .all_attributes()
    .from_file("render.exr")?;
<span class="boring">}</span></code></pre>
<h3 id="pixel-type-conversion"><a class="header" href="#pixel-type-conversion">Pixel Type Conversion</a></h3>
<p>The setter’s pixel type determines conversion:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Read as f16 (native for most EXR)
|vec, pos, (r, g, b, a): (f16, f16, f16, f16)| { ... }

// Read as f32 (automatic conversion)
|vec, pos, (r, g, b, a): (f32, f32, f32, f32)| { ... }

// Keep original type (no conversion)
|vec, pos, (r, g, b, a): (Sample, Sample, Sample, Sample)| { ... }
<span class="boring">}</span></code></pre>
<h2 id="layer-selection"><a class="header" href="#layer-selection">Layer Selection</a></h2>
<h3 id="first-valid-layer"><a class="header" href="#first-valid-layer">First Valid Layer</a></h3>
<p>Get the first layer matching your channel requirements:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.first_valid_layer()
<span class="boring">}</span></code></pre>
<h3 id="all-layers"><a class="header" href="#all-layers">All Layers</a></h3>
<p>Get all layers as a <code>Vec</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.all_layers()
<span class="boring">}</span></code></pre>
<h3 id="all-valid-layers"><a class="header" href="#all-valid-layers">All Valid Layers</a></h3>
<p>Get all layers matching your channel requirements (skips incompatible layers):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let image = read()
    .no_deep_data()
    .largest_resolution_level()
    .rgb_channels(...)
    .all_valid_layers()  // Only layers with RGB
    .all_attributes()
    .from_file("mixed.exr")?;

if image.layer_data.is_empty() {
    println!("No RGB layers found");
}
<span class="boring">}</span></code></pre>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>Currently, you must load all attributes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.all_attributes()
<span class="boring">}</span></code></pre>
<p>Access them after loading:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let image = read_all_data_from_file("image.exr")?;

// Image-level attributes
let display = &amp;image.attributes.display_window;
println!("Display window: {:?}", display);

// Layer-level attributes
for layer in &amp;image.layer_data {
    if let Some(name) = &amp;layer.attributes.layer_name {
        println!("Layer: {}", name);
    }
    
    // Custom attributes
    for (key, value) in &amp;layer.attributes.other {
        println!("  {}: {:?}", key, value);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="reading-options"><a class="header" href="#reading-options">Reading Options</a></h2>
<h3 id="progress-callback"><a class="header" href="#progress-callback">Progress Callback</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.on_progress(|progress: f64| {
    println!("{}% complete", (progress * 100.0) as i32);
})
<span class="boring">}</span></code></pre>
<h3 id="non-parallel"><a class="header" href="#non-parallel">Non-Parallel</a></h3>
<p>Disable multi-threaded decompression:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.non_parallel()
<span class="boring">}</span></code></pre>
<h3 id="pedantic-mode"><a class="header" href="#pedantic-mode">Pedantic Mode</a></h3>
<p>Strict validation (rejects some valid-but-unusual files):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::image::read::ReadOptions;

// Via builder (if available)
// Or via low-level API
<span class="boring">}</span></code></pre>
<h2 id="input-sources"><a class="header" href="#input-sources">Input Sources</a></h2>
<h3 id="file-path"><a class="header" href="#file-path">File Path</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.from_file("image.exr")?
.from_file(PathBuf::from("image.exr"))?
.from_file(Path::new("image.exr"))?
<span class="boring">}</span></code></pre>
<h3 id="buffered-reader"><a class="header" href="#buffered-reader">Buffered Reader</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Cursor;

let bytes: Vec&lt;u8&gt; = load_from_network();
let cursor = Cursor::new(bytes);

.from_buffered(cursor)?
<span class="boring">}</span></code></pre>
<h3 id="unbuffered-reader"><a class="header" href="#unbuffered-reader">Unbuffered Reader</a></h3>
<p>The library will add buffering:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

let file = File::open("image.exr")?;
.from_unbuffered(file)?
<span class="boring">}</span></code></pre>
<h2 id="result-types"><a class="header" href="#result-types">Result Types</a></h2>
<p>The type of <code>image</code> depends on your choices:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// read_all_data_from_file
Image&lt;Layers&lt;AnyChannels&lt;FlatSamples&gt;&gt;&gt;

// read_first_flat_layer_from_file  
Image&lt;Layer&lt;AnyChannels&lt;FlatSamples&gt;&gt;&gt;

// With all_resolution_levels()
Image&lt;Layer&lt;AnyChannels&lt;Levels&lt;FlatSamples&gt;&gt;&gt;&gt;

// With rgba_channels + first_valid_layer
Image&lt;Layer&lt;SpecificChannels&lt;YourStorage, RgbaChannels&gt;&gt;&gt;
<span class="boring">}</span></code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

fn load_image() -&gt; Result&lt;(), Error&gt; {
    let image = read_all_data_from_file("image.exr")?;
    Ok(())
}

// Or match explicitly
match read_all_data_from_file("image.exr") {
    Ok(image) =&gt; { /* use image */ }
    Err(Error::Io(e)) =&gt; eprintln!("I/O error: {}", e),
    Err(Error::Invalid(msg)) =&gt; eprintln!("Invalid file: {}", msg),
    Err(Error::NotSupported(msg)) =&gt; eprintln!("Unsupported: {}", msg),
    Err(e) =&gt; eprintln!("Error: {:?}", e),
}
<span class="boring">}</span></code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() -&gt; Result&lt;(), Error&gt; {
    // Load render passes
    let image = read()
        .no_deep_data()
        .largest_resolution_level()
        .specific_channels()
            .required("R")
            .required("G")
            .required("B")
            .optional("A", 1.0_f32)
            .optional("Z", f32::INFINITY)
            .collect_pixels(
                |res, _| {
                    vec![(0f32, 0f32, 0f32, 1f32, f32::INFINITY); 
                         res.width() * res.height()]
                },
                |pixels, pos, pixel: (f32, f32, f32, f32, f32)| {
                    pixels[pos.flat_index()] = pixel;
                }
            )
        .first_valid_layer()
        .all_attributes()
        .on_progress(|p| print!("\rLoading: {:.0}%", p * 100.0))
        .from_file("render.exr")?;
    
    println!("\nLoaded {}x{} image", 
        image.layer_data.size.0, 
        image.layer_data.size.1
    );
    
    Ok(())
}</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#writing-images">Writing Images</a> - Create EXR files</li>
<li><a href="#deep-data">Deep Data</a> - Variable samples per pixel</li>
<li><a href="#image-module">API Reference: Image</a> - Full API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="writing-images"><a class="header" href="#writing-images">Writing Images</a></h1>
<p>This guide covers creating and writing EXR files with exrs.</p>
<h2 id="writing-pipeline-overview"><a class="header" href="#writing-pipeline-overview">Writing Pipeline Overview</a></h2>
<p>Writing an EXR follows this pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// 1. Create channels
let channels = SpecificChannels::rgba(|pos| (r, g, b, a));

// 2. Create layer(s)
let layer = Layer::new(dimensions, attributes, encoding, channels);

// 3. Create image
let image = Image::from_layer(layer);

// 4. Write
image.write().to_file("output.exr")?;
<span class="boring">}</span></code></pre>
<h2 id="convenience-functions-1"><a class="header" href="#convenience-functions-1">Convenience Functions</a></h2>
<h3 id="simple-rgba-1"><a class="header" href="#simple-rgba-1">Simple RGBA</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

write_rgba_file(
    "output.exr",
    1920, 1080,
    |x, y| {
        let r = compute_red(x, y);
        let g = compute_green(x, y);
        let b = compute_blue(x, y);
        let a = 1.0_f32;
        (r, g, b, a)
    }
)?;
<span class="boring">}</span></code></pre>
<h3 id="simple-rgb"><a class="header" href="#simple-rgb">Simple RGB</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

write_rgb_file(
    "output.exr",
    1920, 1080,
    |x, y| {
        (0.5_f32, 0.3_f32, 0.1_f32)
    }
)?;
<span class="boring">}</span></code></pre>
<h2 id="building-images"><a class="header" href="#building-images">Building Images</a></h2>
<h3 id="from-channels"><a class="header" href="#from-channels">From Channels</a></h3>
<p>Simplest way for single-layer images:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let channels = SpecificChannels::rgba(|pos: Vec2&lt;usize&gt;| {
    let x = pos.x() as f32 / 1920.0;
    let y = pos.y() as f32 / 1080.0;
    (x, y, 0.5_f32, 1.0_f32)
});

let image = Image::from_channels((1920, 1080), channels);
image.write().to_file("output.exr")?;
<span class="boring">}</span></code></pre>
<h3 id="from-layer"><a class="header" href="#from-layer">From Layer</a></h3>
<p>More control over layer attributes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let layer = Layer::new(
    (1920, 1080),
    LayerAttributes::named("beauty"),
    Encoding::FAST_LOSSLESS,
    SpecificChannels::rgba(|_| (0.5, 0.5, 0.5, 1.0))
);

let image = Image::from_layer(layer);
image.write().to_file("output.exr")?;
<span class="boring">}</span></code></pre>
<h3 id="multiple-layers"><a class="header" href="#multiple-layers">Multiple Layers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let beauty = Layer::new(
    (1920, 1080),
    LayerAttributes::named("beauty"),
    Encoding::FAST_LOSSLESS,
    SpecificChannels::rgba(|_| (0.5, 0.5, 0.5, 1.0))
);

let depth = Layer::new(
    (1920, 1080),
    LayerAttributes::named("depth"),
    Encoding::FAST_LOSSLESS,
    // Single channel for depth
    SpecificChannels::build()
        .with_channel("Z")
        .with_pixel_fn(|_pos| (1000.0_f32,))
);

let image = Image::empty(ImageAttributes::new(IntegerBounds::from_dimensions((1920, 1080))))
    .with_layer(beauty)
    .with_layer(depth);

image.write().to_file("render.exr")?;
<span class="boring">}</span></code></pre>
<h2 id="channel-types"><a class="header" href="#channel-types">Channel Types</a></h2>
<h3 id="specificchannels-static"><a class="header" href="#specificchannels-static">SpecificChannels (Static)</a></h3>
<p>For known channel layouts:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// RGBA
let channels = SpecificChannels::rgba(|pos| (r, g, b, a));

// RGB
let channels = SpecificChannels::rgb(|pos| (r, g, b));

// Custom channels
let channels = SpecificChannels::build()
    .with_channel("L")
    .with_channel("A")
    .with_channel("B")
    .with_pixel_fn(|pos| (luminance, a_chroma, b_chroma));
<span class="boring">}</span></code></pre>
<h3 id="anychannels-dynamic"><a class="header" href="#anychannels-dynamic">AnyChannels (Dynamic)</a></h3>
<p>For runtime-determined channels:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let width = 1920;
let height = 1080;
let pixel_count = width * height;

let channels = AnyChannels::sort(smallvec![
    AnyChannel::new("R", FlatSamples::F32(vec![0.5; pixel_count])),
    AnyChannel::new("G", FlatSamples::F32(vec![0.3; pixel_count])),
    AnyChannel::new("B", FlatSamples::F32(vec![0.1; pixel_count])),
    AnyChannel::new("A", FlatSamples::F16(vec![f16::ONE; pixel_count])),
    AnyChannel::new("Z", FlatSamples::F32(depth_buffer)),
]);

let layer = Layer::new(
    (width, height),
    LayerAttributes::named("main"),
    Encoding::FAST_LOSSLESS,
    channels
);
<span class="boring">}</span></code></pre>
<h2 id="sample-types"><a class="header" href="#sample-types">Sample Types</a></h2>
<h3 id="half-precision-f16"><a class="header" href="#half-precision-f16">Half Precision (f16)</a></h3>
<p>Most common for color channels - good precision, smaller files:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

SpecificChannels::rgba(|pos| {
    (
        f16::from_f32(0.5),
        f16::from_f32(0.3),
        f16::from_f32(0.1),
        f16::ONE
    )
});

// Or with FlatSamples
AnyChannel::new("R", FlatSamples::F16(half_values));
<span class="boring">}</span></code></pre>
<h3 id="full-precision-f32"><a class="header" href="#full-precision-f32">Full Precision (f32)</a></h3>
<p>For depth, positions, or when precision matters:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

SpecificChannels::build()
    .with_channel("Z")
    .with_pixel_fn(|_| (depth_value as f32,));

// Or with FlatSamples
AnyChannel::new("Z", FlatSamples::F32(depth_values));
<span class="boring">}</span></code></pre>
<h3 id="unsigned-integer-u32"><a class="header" href="#unsigned-integer-u32">Unsigned Integer (u32)</a></h3>
<p>For IDs, object indices, masks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

AnyChannel::new("objectId", FlatSamples::U32(object_ids));
AnyChannel::new("cryptomatte", FlatSamples::U32(crypto_values));
<span class="boring">}</span></code></pre>
<h2 id="compression"><a class="header" href="#compression">Compression</a></h2>
<h3 id="presets"><a class="header" href="#presets">Presets</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// Fast read/write, larger files
Encoding::UNCOMPRESSED

// Good balance of speed and size
Encoding::FAST_LOSSLESS  // ZIP16

// Best lossless compression (slower)
Encoding::SMALL_LOSSLESS  // PIZ

// Lossy but fast decompression
Encoding::SMALL_LOSSY  // B44
<span class="boring">}</span></code></pre>
<h3 id="custom"><a class="header" href="#custom">Custom</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let encoding = Encoding {
    compression: Compression::ZIP16,  // Or ZIPS, RLE, PIZ, B44, etc.
    blocks: Blocks::ScanLines,
    line_order: LineOrder::Increasing,
};
<span class="boring">}</span></code></pre>
<h3 id="compression-comparison-1"><a class="header" href="#compression-comparison-1">Compression Comparison</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Compression</th><th>Lossless</th><th>Speed</th><th>Size</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td><code>Uncompressed</code></td><td>Yes</td><td>Fastest</td><td>Largest</td><td>Debugging, max speed</td></tr>
<tr><td><code>RLE</code></td><td>Yes</td><td>Fast</td><td>Good</td><td>Simple patterns</td></tr>
<tr><td><code>ZIPS</code></td><td>Yes</td><td>Medium</td><td>Good</td><td>General, scanline</td></tr>
<tr><td><code>ZIP16</code></td><td>Yes</td><td>Medium</td><td>Good</td><td>General, 16-line blocks</td></tr>
<tr><td><code>PIZ</code></td><td>Yes</td><td>Slow</td><td>Smallest</td><td>Noisy images</td></tr>
<tr><td><code>PXR24</code></td><td>No*</td><td>Fast</td><td>Small</td><td>Float images</td></tr>
<tr><td><code>B44</code></td><td>No</td><td>Fast</td><td>Small</td><td>Playback</td></tr>
<tr><td><code>B44A</code></td><td>No</td><td>Fast</td><td>Small</td><td>With flat areas</td></tr>
</tbody>
</table>
</div>
<p>*PXR24 is lossless for f16 and u32.</p>
<h2 id="metadata-1"><a class="header" href="#metadata-1">Metadata</a></h2>
<h3 id="layer-attributes"><a class="header" href="#layer-attributes">Layer Attributes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let mut attrs = LayerAttributes::named("beauty_pass");

// Optional built-in attributes
attrs.owner = Some(Text::from("Studio Name"));
attrs.comments = Some(Text::from("Final render"));
attrs.software_name = Some(Text::from("My Renderer 2.0"));
attrs.capture_date = Some(/* chrono datetime */);

// Custom attributes
attrs.other.insert(
    Text::from("renderTime"),
    AttributeValue::F32(3600.5)
);
attrs.other.insert(
    Text::from("samples"),  
    AttributeValue::I32(4096)
);
attrs.other.insert(
    Text::from("camera"),
    AttributeValue::Text(Text::from("shot_cam_01"))
);
<span class="boring">}</span></code></pre>
<h3 id="image-attributes"><a class="header" href="#image-attributes">Image Attributes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let mut img_attrs = ImageAttributes::new(
    IntegerBounds::from_dimensions((1920, 1080))
);

img_attrs.pixel_aspect = 1.0;
img_attrs.time_code = Some(TimeCode { /* ... */ });
<span class="boring">}</span></code></pre>
<h2 id="tiles-vs-scanlines"><a class="header" href="#tiles-vs-scanlines">Tiles vs Scanlines</a></h2>
<h3 id="scanline-default"><a class="header" href="#scanline-default">Scanline (Default)</a></h3>
<p>Good for sequential access:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let encoding = Encoding {
    blocks: Blocks::ScanLines,
    ..Default::default()
};
<span class="boring">}</span></code></pre>
<h3 id="tiles"><a class="header" href="#tiles">Tiles</a></h3>
<p>Better for random access and very large images:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let encoding = Encoding {
    blocks: Blocks::Tiles(TileDescription {
        tile_size: Vec2(64, 64),
        level_mode: LevelMode::Singular,
        rounding_mode: RoundingMode::Down,
    }),
    ..Default::default()
};
<span class="boring">}</span></code></pre>
<h2 id="mip-maps"><a class="header" href="#mip-maps">Mip Maps</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// Generate mip levels
let level0: Vec&lt;f32&gt; = original_pixels;
let level1: Vec&lt;f32&gt; = downsample(&amp;level0, 2);
let level2: Vec&lt;f32&gt; = downsample(&amp;level1, 2);

let levels = Levels::Mip {
    rounding_mode: RoundingMode::Down,
    level_data: vec![
        FlatSamples::F32(level0),
        FlatSamples::F32(level1),
        FlatSamples::F32(level2),
    ].into()
};

let channel = AnyChannel::new("R", levels);
<span class="boring">}</span></code></pre>
<h2 id="writing-options"><a class="header" href="#writing-options">Writing Options</a></h2>
<h3 id="progress-callback-1"><a class="header" href="#progress-callback-1">Progress Callback</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>image.write()
    .on_progress(|progress: f64| {
        print!("\rWriting: {:.1}%", progress * 100.0);
    })
    .to_file("output.exr")?;
<span class="boring">}</span></code></pre>
<h3 id="non-parallel-1"><a class="header" href="#non-parallel-1">Non-Parallel</a></h3>
<p>Disable multi-threaded compression:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>image.write()
    .non_parallel()
    .to_file("output.exr")?;
<span class="boring">}</span></code></pre>
<h2 id="output-destinations"><a class="header" href="#output-destinations">Output Destinations</a></h2>
<h3 id="file-path-1"><a class="header" href="#file-path-1">File Path</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>image.write().to_file("output.exr")?;
image.write().to_file(Path::new("output.exr"))?;
image.write().to_file(PathBuf::from("output.exr"))?;
<span class="boring">}</span></code></pre>
<h3 id="buffered-writer"><a class="header" href="#buffered-writer">Buffered Writer</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Cursor;

let mut buffer = Vec::new();
let cursor = Cursor::new(&amp;mut buffer);
image.write().to_buffered(cursor)?;
// buffer now contains EXR bytes
<span class="boring">}</span></code></pre>
<h3 id="unbuffered-writer"><a class="header" href="#unbuffered-writer">Unbuffered Writer</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

let file = File::create("output.exr")?;
image.write().to_unbuffered(file)?;
<span class="boring">}</span></code></pre>
<h2 id="complete-examples"><a class="header" href="#complete-examples">Complete Examples</a></h2>
<h3 id="render-output"><a class="header" href="#render-output">Render Output</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

fn save_render(
    path: &amp;str,
    width: usize,
    height: usize,
    rgba: &amp;[(f32, f32, f32, f32)],
    depth: &amp;[f32],
) -&gt; Result&lt;(), Error&gt; {
    let beauty = Layer::new(
        (width, height),
        LayerAttributes::named("rgba"),
        Encoding::FAST_LOSSLESS,
        SpecificChannels::rgba(|pos| rgba[pos.y() * width + pos.x()])
    );
    
    let depth_layer = Layer::new(
        (width, height),
        LayerAttributes::named("depth"),
        Encoding {
            compression: Compression::ZIPS,
            ..Default::default()
        },
        SpecificChannels::build()
            .with_channel("Z")
            .with_pixel_fn(|pos| (depth[pos.y() * width + pos.x()],))
    );
    
    Image::empty(ImageAttributes::new(IntegerBounds::from_dimensions((width, height))))
        .with_layer(beauty)
        .with_layer(depth_layer)
        .write()
        .on_progress(|p| print!("\rSaving: {:.0}%", p * 100.0))
        .to_file(path)?;
    
    println!(" Done!");
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="dynamic-channel-creation"><a class="header" href="#dynamic-channel-creation">Dynamic Channel Creation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

fn save_aov_bundle(
    path: &amp;str,
    width: usize,
    height: usize,
    aovs: &amp;[(&amp;str, Vec&lt;f32&gt;)],
) -&gt; Result&lt;(), Error&gt; {
    let pixel_count = width * height;
    
    let channels: SmallVec&lt;[AnyChannel&lt;FlatSamples&gt;; 8]&gt; = aovs.iter()
        .map(|(name, data)| {
            AnyChannel::new(*name, FlatSamples::F32(data.clone()))
        })
        .collect();
    
    let layer = Layer::new(
        (width, height),
        LayerAttributes::named("aovs"),
        Encoding::FAST_LOSSLESS,
        AnyChannels::sort(channels)
    );
    
    Image::from_layer(layer)
        .write()
        .to_file(path)
}
<span class="boring">}</span></code></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="#reading-images">Reading Images</a> - Load EXR files</li>
<li><a href="#deep-data">Deep Data</a> - Variable samples per pixel</li>
<li><a href="#image-module">API Reference: Image</a> - Full API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="deep-data"><a class="header" href="#deep-data">Deep Data</a></h1>
<p>Deep data (OpenEXR 2.0+) stores a <strong>variable number of samples per pixel</strong>. This is essential for volumetric effects, particles, and advanced compositing.</p>
<h2 id="flat-vs-deep"><a class="header" href="#flat-vs-deep">Flat vs Deep</a></h2>
<pre><code>Flat image:  1 sample per pixel
  Pixel (10, 20) = RGBA(0.5, 0.3, 0.1, 1.0)

Deep image:  N samples per pixel (0 to thousands)
  Pixel (10, 20) = [
    {Z=1.5, RGBA(0.2, 0.1, 0.0, 0.3)},  // Smoke layer
    {Z=5.0, RGBA(0.8, 0.6, 0.4, 1.0)},  // Solid object
    {Z=8.2, RGBA(0.1, 0.1, 0.1, 0.1)},  // Background fog
  ]
</code></pre>
<h2 id="when-to-use-deep-data"><a class="header" href="#when-to-use-deep-data">When to Use Deep Data</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Why Deep?</th></tr>
</thead>
<tbody>
<tr><td><strong>Volumetrics</strong></td><td>Smoke, fog, clouds with proper depth sorting</td></tr>
<tr><td><strong>Particles</strong></td><td>Each particle at its true depth</td></tr>
<tr><td><strong>Hair/Fur</strong></td><td>Multiple transparent strands per pixel</td></tr>
<tr><td><strong>Deep Compositing</strong></td><td>Layer elements without pre-flattening</td></tr>
<tr><td><strong>Hold-out Mattes</strong></td><td>Correct occlusion with complex geometry</td></tr>
</tbody>
</table>
</div>
<h2 id="reading-deep-images"><a class="header" href="#reading-deep-images">Reading Deep Images</a></h2>
<h3 id="simple-api"><a class="header" href="#simple-api">Simple API</a></h3>
<pre class="playground"><code class="language-rust">use exr::image::read::deep::read_first_deep_layer_from_file;

fn main() {
    let image = read_first_deep_layer_from_file("particles.exr")
        .expect("Failed to read deep EXR");
    
    let layer = &amp;image.layer_data;
    let samples = &amp;layer.channel_data.list[0].sample_data;
    
    println!("Image size: {}x{}", samples.width, samples.height);
    println!("Total samples: {}", samples.total_samples());
    println!("Max per pixel: {}", samples.max_samples_per_pixel());
}</code></pre>
<h3 id="builder-api"><a class="header" href="#builder-api">Builder API</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::image::read::deep::read_deep;

let image = read_deep()
    .all_channels()
    .first_valid_layer()
    .all_attributes()
    .from_file("volumetric.exr")?;

// Multiple layers
let multi = read_deep()
    .all_channels()
    .all_layers()
    .all_attributes()
    .from_file("layered_deep.exr")?;
<span class="boring">}</span></code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::image::read::deep::read_deep;

let image = read_deep()
    .all_channels()
    .first_valid_layer()
    .all_attributes()
    .non_parallel()     // Single-threaded (debugging)
    .pedantic()         // Strict validation
    .on_progress(|p| println!("{}%", (p * 100.0) as i32))
    .from_file("deep.exr")?;
<span class="boring">}</span></code></pre>
<h2 id="the-deepsamples-structure"><a class="header" href="#the-deepsamples-structure">The DeepSamples Structure</a></h2>
<p>Deep data uses a Struct-of-Arrays (SoA) layout for efficiency:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DeepSamples {
    /// Cumulative sample counts per pixel
    /// Length = width * height
    pub sample_offsets: Vec&lt;u32&gt;,
    
    /// Channel data arrays, each length = total_samples
    pub channels: Vec&lt;DeepChannelData&gt;,
    
    pub width: usize,
    pub height: usize,
}

pub enum DeepChannelData {
    F16(Vec&lt;f16&gt;),
    F32(Vec&lt;f32&gt;),
    U32(Vec&lt;u32&gt;),
}
<span class="boring">}</span></code></pre>
<h3 id="sample-offset-encoding"><a class="header" href="#sample-offset-encoding">Sample Offset Encoding</a></h3>
<p>Offsets are cumulative (prefix sum):</p>
<pre><code>Pixel:          [0]  [1]  [2]  [3]
Sample count:    2    0    3    1
Offsets:         2    2    5    6
                 ^    ^    ^    ^
Ranges:       0..2  2..2 2..5  5..6
</code></pre>
<h3 id="accessing-samples"><a class="header" href="#accessing-samples">Accessing Samples</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::image::deep::{DeepSamples, DeepChannelData};

fn process_samples(samples: &amp;DeepSamples) {
    // Get count for a specific pixel
    let count = samples.sample_count(10, 20);
    println!("Pixel (10, 20) has {} samples", count);
    
    // Get sample range for direct array access
    let pixel_idx = 20 * samples.width + 10;
    let (start, end) = samples.sample_range(pixel_idx);
    
    // Access channel data
    for (ch_idx, channel) in samples.channels.iter().enumerate() {
        match channel {
            DeepChannelData::F16(data) =&gt; {
                for i in start..end {
                    let value = data[i];
                    println!("  Ch{} sample {}: {}", ch_idx, i - start, value);
                }
            }
            DeepChannelData::F32(data) =&gt; {
                for i in start..end {
                    let depth = data[i];
                    println!("  Ch{} sample {}: {}", ch_idx, i - start, depth);
                }
            }
            DeepChannelData::U32(data) =&gt; {
                for i in start..end {
                    let id = data[i];
                    println!("  Ch{} sample {}: {}", ch_idx, i - start, id);
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="iterating-all-pixels"><a class="header" href="#iterating-all-pixels">Iterating All Pixels</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn iterate_deep_image(samples: &amp;DeepSamples) {
    for y in 0..samples.height {
        for x in 0..samples.width {
            let count = samples.sample_count(x, y);
            if count == 0 {
                continue;  // Skip empty pixels
            }
            
            let pixel_idx = y * samples.width + x;
            let (start, end) = samples.sample_range(pixel_idx);
            
            // Process samples at this pixel
            for sample_idx in start..end {
                // Access all channels for this sample
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="writing-deep-images"><a class="header" href="#writing-deep-images">Writing Deep Images</a></h2>
<pre class="playground"><code class="language-rust">use exr::image::read::deep::read_first_deep_layer_from_file;
use exr::image::write::deep::write_deep_image_to_file;
use exr::compression::Compression;

fn main() {
    // Read a deep image
    let image = read_first_deep_layer_from_file("input.exr").unwrap();
    
    // Write with compression
    write_deep_image_to_file(
        "output.exr",
        &amp;image,
        Compression::ZIP1,  // Recommended for deep
    ).unwrap();
}</code></pre>
<h2 id="compression-for-deep-data"><a class="header" href="#compression-for-deep-data">Compression for Deep Data</a></h2>
<p>Not all compression methods support deep data:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Deep Support</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>Uncompressed</code></td><td>Yes</td><td>Fastest, largest</td></tr>
<tr><td><code>RLE</code></td><td>Yes</td><td>Good for sparse data</td></tr>
<tr><td><code>ZIPS</code></td><td>Yes</td><td>Single scanline ZIP</td></tr>
<tr><td><code>ZIP</code></td><td>Yes</td><td><strong>Recommended</strong></td></tr>
<tr><td><code>PIZ</code></td><td>No</td><td>Lossy elements incompatible</td></tr>
<tr><td><code>PXR24</code></td><td>No</td><td>Float truncation</td></tr>
<tr><td><code>B44/B44A</code></td><td>No</td><td>Fixed-size blocks</td></tr>
<tr><td><code>DWAA/DWAB</code></td><td>No</td><td>Not implemented</td></tr>
</tbody>
</table>
</div>
<h2 id="parallel-decompression"><a class="header" href="#parallel-decompression">Parallel Decompression</a></h2>
<p>Deep reading supports parallel decompression:</p>
<pre><code>Sequential:  File → Read → Decompress → Decompress → ... → Merge
Parallel:    File → Read ─┬→ Thread 1 → ┐
                          ├→ Thread 2 → ├→ Sort → Merge
                          └→ Thread 3 → ┘
</code></pre>
<p>Benchmark results (release build):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Samples</th><th>Sequential</th><th>Parallel</th><th>Speedup</th></tr>
</thead>
<tbody>
<tr><td>Teaset720p.exr</td><td>997K</td><td>199ms</td><td>79ms</td><td><strong>2.52x</strong></td></tr>
<tr><td>Ground.exr</td><td>360K</td><td>84ms</td><td>37ms</td><td><strong>2.27x</strong></td></tr>
<tr><td>MiniCooper720p.exr</td><td>932K</td><td>150ms</td><td>84ms</td><td><strong>1.79x</strong></td></tr>
</tbody>
</table>
</div>
<h2 id="unified-deepflat-reading"><a class="header" href="#unified-deepflat-reading">Unified Deep/Flat Reading</a></h2>
<p>When you don’t know if a file is deep or flat:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let image = read_first_any_layer_from_file("unknown.exr")?;

// Check what we got
for channel in &amp;image.layer_data.channel_data.list {
    match &amp;channel.sample_data {
        DeepAndFlatSamples::Deep(deep) =&gt; {
            println!("{}: Deep, {} total samples", 
                channel.name, deep.total_samples());
        }
        DeepAndFlatSamples::Flat(flat) =&gt; {
            println!("{}: Flat, {} samples", 
                channel.name, flat.len());
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="deep-compositing-workflow"><a class="header" href="#deep-compositing-workflow">Deep Compositing Workflow</a></h2>
<p>Deep compositing preserves depth information through the pipeline:</p>
<pre><code>                    Traditional                    Deep
                    
Render A       ─┐                             ─┐
                ├─&gt; Pre-multiply ─&gt; Composite   ├─&gt; Deep Merge ─&gt; Flatten
Render B       ─┘                             ─┘
                    
                    ⚠ Artifacts at edges        ✓ Correct everywhere
</code></pre>
<h3 id="basic-deep-composite"><a class="header" href="#basic-deep-composite">Basic Deep Composite</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn deep_over(front: &amp;DeepSamples, back: &amp;DeepSamples) -&gt; DeepSamples {
    // For each pixel:
    // 1. Combine samples from both images
    // 2. Sort by depth (Z)
    // 3. Composite front-to-back
    // ... implementation depends on your needs
}
<span class="boring">}</span></code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p><code>DeepSamples</code> validates its structure:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DeepSamples {
    pub fn validate(&amp;self) -&gt; Result&lt;()&gt; {
        // 1. Offset array length = width * height
        // 2. Offsets never decrease (monotonic)
        // 3. All channels have total_samples elements
        // 4. No overflow
    }
}
<span class="boring">}</span></code></pre>
<h2 id="memory-considerations"><a class="header" href="#memory-considerations">Memory Considerations</a></h2>
<p>Deep images can be large:</p>
<pre><code>Flat 1920x1080 RGBA f16:  1920 * 1080 * 4 * 2 = 16 MB
Deep same resolution:     Depends on content
  - Sparse (avg 0.1):     ~1.6 MB
  - Dense (avg 10):       ~160 MB
  - Very dense (avg 100): ~1.6 GB
</code></pre>
<p>Tips:</p>
<ul>
<li>Check <code>total_samples()</code> before processing</li>
<li>Use <code>sample_count()</code> to skip empty pixels</li>
<li>Process in streaming fashion when possible</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Current implementation limitations:</p>
<ol>
<li><strong>Full image loading</strong> - Entire deep image loaded to memory</li>
<li><strong>Single-layer optimization</strong> - Multi-layer re-reads file</li>
<li><strong>Tile support</strong> - Implemented but less tested</li>
<li><strong>No mipmap</strong> - Mip/rip maps not supported for deep</li>
</ol>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="#deep-data-support">Our Deep Data Enhancements</a> - What we added</li>
<li><a href="#deep-data-module">API Reference: Deep</a> - Full API documentation</li>
<li><a href="https://openexr.com/en/latest/TechnicalIntroduction.html">OpenEXR Deep Compositing</a> - Official docs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="our-enhancements"><a class="header" href="#our-enhancements">Our Enhancements</a></h1>
<p>This fork of exrs significantly extends the original library with new features, improved APIs, and comprehensive deep data support.</p>
<h2 id="enhancement-summary"><a class="header" href="#enhancement-summary">Enhancement Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Lines Added</th><th>Key Features</th></tr>
</thead>
<tbody>
<tr><td><strong>Deep Data</strong></td><td>~3,500</td><td>Full OpenEXR 2.0 deep support</td></tr>
<tr><td><strong>Unified Reader</strong></td><td>~800</td><td>Read any file without knowing format</td></tr>
<tr><td><strong>Level Selection</strong></td><td>~400</td><td>Choose specific mipmap levels</td></tr>
<tr><td><strong>Layer Filtering</strong></td><td>~300</td><td>Read only matching layers</td></tr>
<tr><td><strong>Compression</strong></td><td>~1,600</td><td>Deep compression, optimizations</td></tr>
<tr><td><strong>Block Layer</strong></td><td>~1,100</td><td>Deep block I/O, validation</td></tr>
<tr><td><strong>Metadata</strong></td><td>~2,300</td><td>Deep headers, attributes</td></tr>
<tr><td><strong>Tests</strong></td><td>~600</td><td>Deep tests, benchmarks</td></tr>
</tbody>
</table>
</div>
<p><strong>Total: ~25,000 lines added, ~4,000 removed, 82 files modified</strong></p>
<h2 id="major-features"><a class="header" href="#major-features">Major Features</a></h2>
<h3 id="1-deep-data-support-openexr-20"><a class="header" href="#1-deep-data-support-openexr-20">1. Deep Data Support (OpenEXR 2.0)</a></h3>
<p>Complete implementation of variable samples per pixel:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::image::read::deep::read_first_deep_layer_from_file;

let deep = read_first_deep_layer_from_file("particles.exr")?;
let samples = &amp;deep.layer_data.channel_data.list[0].sample_data;

println!("Total samples: {}", samples.total_samples());
for y in 0..samples.height {
    for x in 0..samples.width {
        let count = samples.sample_count(x, y);
        if count &gt; 0 {
            // Process samples
        }
    }
}
<span class="boring">}</span></code></pre>
<p><a href="#deep-data-support">Read more about Deep Data Support</a></p>
<h3 id="2-unified-deepflat-reader"><a class="header" href="#2-unified-deepflat-reader">2. Unified Deep/Flat Reader</a></h3>
<p>Read any EXR file without knowing if it’s deep or flat:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let image = read_first_any_layer_from_file("unknown.exr")?;

for channel in &amp;image.layer_data.channel_data.list {
    match &amp;channel.sample_data {
        DeepAndFlatSamples::Deep(deep) =&gt; {
            println!("{}: Deep with {} samples", 
                channel.name, deep.total_samples());
        }
        DeepAndFlatSamples::Flat(flat) =&gt; {
            println!("{}: Flat with {} samples", 
                channel.name, flat.len());
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="3-specific-resolution-level-selection"><a class="header" href="#3-specific-resolution-level-selection">3. Specific Resolution Level Selection</a></h3>
<p>Load exactly the mipmap level you need:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// Load level 1 (half resolution)
let image = read()
    .no_deep_data()
    .specific_resolution_level(|_| Vec2(1, 1))
    .all_channels()
    .first_valid_layer()
    .from_file("mipmapped.exr")?;

// Load level closest to 512px
let image = read()
    .no_deep_data()
    .specific_resolution_level(|levels| {
        levels.iter()
            .min_by_key(|l| (l.resolution.x() as i64 - 512).abs())
            .map(|l| l.index)
            .unwrap_or(Vec2(0, 0))
    })
    .all_channels()
    .first_valid_layer()
    .from_file("mipmapped.exr")?;
<span class="boring">}</span></code></pre>
<h3 id="4-all-valid-layers-reader"><a class="header" href="#4-all-valid-layers-reader">4. All Valid Layers Reader</a></h3>
<p>Read only layers matching your channel requirements:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let image = read()
    .no_deep_data()
    .largest_resolution_level()
    .rgb_channels(create_pixels, set_pixel)
    .all_valid_layers()  // Skip layers without RGB
    .all_attributes()
    .from_file("mixed_layers.exr")?;

println!("Found {} RGB layers", image.layer_data.len());
<span class="boring">}</span></code></pre>
<h3 id="5-parallel-deep-decompression"><a class="header" href="#5-parallel-deep-decompression">5. Parallel Deep Decompression</a></h3>
<p>Automatic multi-threaded decompression for deep data:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Sequential</th><th>Parallel</th><th>Speedup</th></tr>
</thead>
<tbody>
<tr><td>Teaset720p.exr</td><td>199ms</td><td>79ms</td><td><strong>2.52x</strong></td></tr>
<tr><td>Ground.exr</td><td>84ms</td><td>37ms</td><td><strong>2.27x</strong></td></tr>
<tr><td>MiniCooper720p.exr</td><td>150ms</td><td>84ms</td><td><strong>1.79x</strong></td></tr>
</tbody>
</table>
</div>
<p><a href="#general-improvements">Read more about General Improvements</a></p>
<h2 id="breaking-changes"><a class="header" href="#breaking-changes">Breaking Changes</a></h2>
<p><strong>None</strong> - All changes are additive and backwards compatible with existing code.</p>
<h2 id="branch-information"><a class="header" href="#branch-information">Branch Information</a></h2>
<ul>
<li><strong>Branch:</strong> <code>deep</code></li>
<li><strong>Base:</strong> <code>master</code> (v1.74.0)</li>
<li><strong>Status:</strong> All tests passing</li>
</ul>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What’s Next</a></h2>
<ul>
<li><a href="#deep-data-support">Deep Data Support</a> - Detailed deep data documentation</li>
<li><a href="#general-improvements">General Improvements</a> - Other enhancements and optimizations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="deep-data-support"><a class="header" href="#deep-data-support">Deep Data Support</a></h1>
<p>Our implementation brings full OpenEXR 2.0 deep data support to the exrs library.</p>
<h2 id="what-we-added"><a class="header" href="#what-we-added">What We Added</a></h2>
<h3 id="core-types-srcimagedeeprs"><a class="header" href="#core-types-srcimagedeeprs">Core Types (<code>src/image/deep.rs</code>)</a></h3>
<p>New module providing deep data structures:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Variable samples per pixel
pub struct DeepSamples {
    pub sample_offsets: Vec&lt;u32&gt;,      // Cumulative counts
    pub channels: Vec&lt;DeepChannelData&gt;, // Channel arrays
    pub width: usize,
    pub height: usize,
}

pub enum DeepChannelData {
    F16(Vec&lt;f16&gt;),
    F32(Vec&lt;f32&gt;),
    U32(Vec&lt;u32&gt;),
}
<span class="boring">}</span></code></pre>
<p><strong>Features:</strong></p>
<ul>
<li><code>total_samples()</code> - Total sample count across all pixels</li>
<li><code>max_samples_per_pixel()</code> - Maximum density</li>
<li><code>sample_count(x, y)</code> - Count at specific pixel</li>
<li><code>sample_range(idx)</code> - Array range for pixel</li>
<li>Memory-efficient cumulative offset storage</li>
</ul>
<h3 id="block-level-support-srcblockdeeprs"><a class="header" href="#block-level-support-srcblockdeeprs">Block-Level Support (<code>src/block/deep.rs</code>)</a></h3>
<p>843 lines of deep block processing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DeepBlockReader { ... }
pub struct DeepBlockWriter { ... }

// Decompression
pub fn decompress_deep_scanline_block(...) -&gt; Result&lt;DeepUncompressedBlock&gt;
pub fn decompress_deep_tile_block(...) -&gt; Result&lt;DeepUncompressedBlock&gt;

// Compression  
pub fn compress_deep_block(...) -&gt; Result&lt;CompressedDeepBlock&gt;
<span class="boring">}</span></code></pre>
<p><strong>Capabilities:</strong></p>
<ul>
<li>Sample count table encoding/decoding</li>
<li>Deep scanline and tile support</li>
<li>Integration with all supported compression methods</li>
<li>Validation of deep block structure</li>
</ul>
<h3 id="high-level-reading-srcimagereaddeeprs"><a class="header" href="#high-level-reading-srcimagereaddeeprs">High-Level Reading (<code>src/image/read/deep.rs</code>)</a></h3>
<p>919 lines providing intuitive API:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::image::read::deep::{read_deep, read_first_deep_layer_from_file};

// Simple
let image = read_first_deep_layer_from_file("particles.exr")?;

// Builder pattern
let image = read_deep()
    .all_channels()
    .first_valid_layer()  // or .all_layers()
    .all_attributes()
    .non_parallel()       // optional
    .pedantic()           // optional
    .on_progress(|p| ...) // optional
    .from_file("volumetric.exr")?;
<span class="boring">}</span></code></pre>
<h3 id="high-level-writing-srcimagewritedeeprs"><a class="header" href="#high-level-writing-srcimagewritedeeprs">High-Level Writing (<code>src/image/write/deep.rs</code>)</a></h3>
<p>636 lines for deep output:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::image::write::deep::write_deep_image_to_file;
use exr::compression::Compression;

write_deep_image_to_file(
    "output.exr",
    &amp;deep_image,
    Compression::ZIP1,
)?;
<span class="boring">}</span></code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Automatic sample table generation</li>
<li>All lossless compression methods</li>
<li>Scanline and tile modes</li>
<li>Multi-layer deep images</li>
</ul>
<h3 id="unified-reader-srcimagereadany_samplesrs"><a class="header" href="#unified-reader-srcimagereadany_samplesrs">Unified Reader (<code>src/image/read/any_samples.rs</code>)</a></h3>
<p>764 lines for format-agnostic reading:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

let image = read_first_any_layer_from_file("unknown.exr")?;

match &amp;channel.sample_data {
    DeepAndFlatSamples::Deep(samples) =&gt; { /* deep */ }
    DeepAndFlatSamples::Flat(samples) =&gt; { /* flat */ }
}
<span class="boring">}</span></code></pre>
<h3 id="parallel-decompression-1"><a class="header" href="#parallel-decompression-1">Parallel Decompression</a></h3>
<p>Multi-threaded deep block processing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "rayon")]
pub struct ParallelDeepBlockDecompressor&lt;R: ChunksReader&gt; {
    remaining_chunks: R,
    sender: mpsc::Sender&lt;Result&lt;DeepUncompressedBlock&gt;&gt;,
    receiver: mpsc::Receiver&lt;Result&lt;DeepUncompressedBlock&gt;&gt;,
    pool: rayon_core::ThreadPool,
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>Pipeline:</strong></p>
<ol>
<li>Main thread reads compressed chunks</li>
<li>Chunks dispatched to thread pool</li>
<li>Decompressed blocks sent via channel</li>
<li>Blocks sorted by y-coordinate</li>
<li>Merged into final <code>DeepSamples</code></li>
</ol>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<pre><code>                    READING                          WRITING
                    
File on disk                                 DeepSamples in memory
     │                                              │
     ▼                                              ▼
CompressedDeepScanLineBlock                  pack_deep_channels()
     │                                              │
     ├── sample_count_table ◄───────────────► compress_sample_table()
     │         │                                    │
     │         ▼                                    │
     │   decompress &amp; validate                      │
     │         │                                    │
     │         ▼                                    │
     │   cumulative offsets                         │
     │                                              │
     └── sample_data ◄──────────────────────► compress_sample_data()
              │                                     │
              ▼                                     ▼
         decompress                          CompressedDeepBlock
              │                                     │
              ▼                                     ▼
         unpack_channels                     File on disk
              │
              ▼
         DeepSamples
</code></pre>
<h2 id="compression-support"><a class="header" href="#compression-support">Compression Support</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Deep Support</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Uncompressed</td><td>Yes</td><td>Fastest I/O</td></tr>
<tr><td>RLE</td><td>Yes</td><td>Good for sparse</td></tr>
<tr><td>ZIPS</td><td>Yes</td><td>Single scanline</td></tr>
<tr><td>ZIP</td><td>Yes</td><td><strong>Recommended</strong></td></tr>
<tr><td>PIZ</td><td>No</td><td>Incompatible</td></tr>
<tr><td>PXR24</td><td>No</td><td>Float truncation</td></tr>
<tr><td>B44/B44A</td><td>No</td><td>Fixed blocks</td></tr>
</tbody>
</table>
</div>
<h2 id="file-format-details"><a class="header" href="#file-format-details">File Format Details</a></h2>
<h3 id="block-structure"><a class="header" href="#block-structure">Block Structure</a></h3>
<pre><code>CompressedDeepScanLineBlock
├── y_coordinate: i32
├── compressed_pixel_offset_table: Vec&lt;u8&gt;  ← ZIP compressed
├── compressed_sample_data: Vec&lt;u8&gt;         ← ZIP compressed
└── decompressed_sample_data_size: usize
</code></pre>
<h3 id="offset-table-format"><a class="header" href="#offset-table-format">Offset Table Format</a></h3>
<p><strong>Critical difference from memory format:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>File</th><th>Memory</th></tr>
</thead>
<tbody>
<tr><td>Scope</td><td>Per-scanline</td><td>Full image</td></tr>
<tr><td>Reset</td><td>Each line → 0</td><td>Continuous</td></tr>
<tr><td>Type</td><td>i32</td><td>u32</td></tr>
</tbody>
</table>
</div>
<pre><code>Per-line counts: [2, 1, 3]  [0, 2, 1]
File offsets:    [2, 3, 6,   0, 2, 3]  ← restarts!
Memory offsets:  [2, 3, 6,   6, 8, 9]  ← continuous
</code></pre>
<h2 id="tests-added"><a class="header" href="#tests-added">Tests Added</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<ul>
<li><code>deep_read.rs</code> - 176 lines</li>
<li><code>deep_benchmark.rs</code> - 61 lines</li>
<li>Deep roundtrip tests</li>
<li>Deep fuzzing integration</li>
</ul>
<h3 id="test-images"><a class="header" href="#test-images">Test Images</a></h3>
<p>Official OpenEXR deep test files:</p>
<ul>
<li><code>MiniCooper720p.exr</code> (932K samples)</li>
<li><code>PiranhnaAlienRun720p.exr</code></li>
<li><code>Teaset720p.exr</code> (997K samples)</li>
<li><code>Ground.exr</code>, <code>Balls.exr</code>, etc.</li>
</ul>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Benchmark results (release build, ZIP compression):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Samples</th><th>Sequential</th><th>Parallel</th><th>Speedup</th></tr>
</thead>
<tbody>
<tr><td>Teaset720p.exr</td><td>997K</td><td>199ms</td><td>79ms</td><td>2.52x</td></tr>
<tr><td>Ground.exr</td><td>360K</td><td>84ms</td><td>37ms</td><td>2.27x</td></tr>
<tr><td>MiniCooper720p.exr</td><td>932K</td><td>150ms</td><td>84ms</td><td>1.79x</td></tr>
<tr><td>Balls.exr</td><td>94K</td><td>35ms</td><td>23ms</td><td>1.52x</td></tr>
</tbody>
</table>
</div>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<ol>
<li><strong>Memory</strong> - Full image loaded (no streaming for merge step)</li>
<li><strong>Tiles</strong> - Implemented but less tested than scanlines</li>
<li><strong>Mipmap</strong> - Not implemented for deep tiles</li>
<li><strong>Multi-layer</strong> - Re-reads file for each layer (optimization pending)</li>
</ol>
<h2 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h2>
<h3 id="reading-and-processing"><a class="header" href="#reading-and-processing">Reading and Processing</a></h3>
<pre class="playground"><code class="language-rust">use exr::image::read::deep::read_first_deep_layer_from_file;
use exr::image::deep::DeepChannelData;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let image = read_first_deep_layer_from_file("particles.exr")?;
    let samples = &amp;image.layer_data.channel_data.list[0].sample_data;
    
    println!("Image: {}x{}", samples.width, samples.height);
    println!("Total samples: {}", samples.total_samples());
    
    // Find densest pixel
    let mut max_count = 0;
    let mut max_pos = (0, 0);
    
    for y in 0..samples.height {
        for x in 0..samples.width {
            let count = samples.sample_count(x, y);
            if count &gt; max_count {
                max_count = count;
                max_pos = (x, y);
            }
        }
    }
    
    println!("Densest pixel: {:?} with {} samples", max_pos, max_count);
    Ok(())
}</code></pre>
<h3 id="flattening-deep-to-flat"><a class="header" href="#flattening-deep-to-flat">Flattening Deep to Flat</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn flatten_deep(samples: &amp;DeepSamples, channel_idx: usize) -&gt; Vec&lt;f32&gt; {
    let mut result = vec![0.0; samples.width * samples.height];
    
    for y in 0..samples.height {
        for x in 0..samples.width {
            let pixel_idx = y * samples.width + x;
            let (start, end) = samples.sample_range(pixel_idx);
            
            if let DeepChannelData::F32(data) = &amp;samples.channels[channel_idx] {
                // Simple over composite (front-to-back)
                let mut accumulated = 0.0;
                for i in start..end {
                    accumulated += data[i];  // Simplified - real composite uses alpha
                }
                result[pixel_idx] = accumulated;
            }
        }
    }
    
    result
}
<span class="boring">}</span></code></pre>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="#deep-data">User Guide: Deep Data</a> - User-facing documentation</li>
<li><a href="#deep-data-module">API Reference: Deep</a> - Full API docs</li>
<li><a href="#data-flow-1">Developer Guide: Data Flow</a> - Internal architecture</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="general-improvements"><a class="header" href="#general-improvements">General Improvements</a></h1>
<p>Beyond deep data, we’ve made numerous improvements to the exrs library.</p>
<h2 id="new-api-features"><a class="header" href="#new-api-features">New API Features</a></h2>
<h3 id="specific-resolution-level-selection"><a class="header" href="#specific-resolution-level-selection">Specific Resolution Level Selection</a></h3>
<p>Load exactly the mipmap level you need instead of all or largest only:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// New: Select specific level
let image = read()
    .no_deep_data()
    .specific_resolution_level(|levels: Vec&lt;LevelInfo&gt;| {
        // levels contains: index, resolution for each level
        // Return the level index you want
        Vec2(1, 1)  // Level 1 in both X and Y
    })
    .all_channels()
    .first_valid_layer()
    .from_file("mipmapped.exr")?;
<span class="boring">}</span></code></pre>
<p><strong>New types:</strong></p>
<ul>
<li><code>LevelInfo { index: Vec2&lt;usize&gt;, resolution: Vec2&lt;usize&gt; }</code></li>
<li><code>ReadSpecificLevel&lt;S, F&gt;</code> - Builder type</li>
<li><code>SpecificLevelReader</code> - Reader implementation</li>
</ul>
<p><strong>Use cases:</strong></p>
<ul>
<li>Thumbnail generation (load small level)</li>
<li>LOD systems (load appropriate size)</li>
<li>Memory-constrained environments</li>
</ul>
<h3 id="all-valid-layers-reader"><a class="header" href="#all-valid-layers-reader">All Valid Layers Reader</a></h3>
<p>Read only layers matching your channel requirements:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// Previously: all_layers() would fail if ANY layer lacked RGB
// Now: all_valid_layers() gracefully skips incompatible layers

let image = read()
    .no_deep_data()
    .largest_resolution_level()
    .rgb_channels(constructor, setter)
    .all_valid_layers()  // NEW
    .all_attributes()
    .from_file("mixed_layers.exr")?;

// Check what we got
if image.layer_data.is_empty() {
    println!("No layers matched RGB requirements");
} else {
    println!("Loaded {} RGB layers", image.layer_data.len());
}
<span class="boring">}</span></code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Graceful handling of mixed-format files</li>
<li>Layer index mapping preserved</li>
<li>Works with any channel reader</li>
</ul>
<h3 id="unified-deepflat-reader"><a class="header" href="#unified-deepflat-reader">Unified Deep/Flat Reader</a></h3>
<p>Read any EXR without knowing the format:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;

// New convenience function
let image = read_first_any_layer_from_file("mystery.exr")?;

// New enum for sample data
for channel in &amp;image.layer_data.channel_data.list {
    match &amp;channel.sample_data {
        DeepAndFlatSamples::Deep(deep) =&gt; {
            println!("{}: deep, {} samples", 
                channel.name, deep.total_samples());
        }
        DeepAndFlatSamples::Flat(flat) =&gt; {
            println!("{}: flat, {} samples", 
                channel.name, flat.len());
        }
    }
}

// Helper methods
channel.sample_data.is_deep();
channel.sample_data.is_flat();
<span class="boring">}</span></code></pre>
<h2 id="compression-improvements"><a class="header" href="#compression-improvements">Compression Improvements</a></h2>
<h3 id="deep-data-compression"><a class="header" href="#deep-data-compression">Deep Data Compression</a></h3>
<p>Extended compression module to handle deep data:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// New internal functions
compress_sample_table(compression, counts) -&gt; Result&lt;Vec&lt;u8&gt;&gt;
decompress_sample_table(compression, data, width, height) -&gt; Result&lt;Vec&lt;i32&gt;&gt;
compress_sample_data(compression, data, channels) -&gt; Result&lt;Vec&lt;u8&gt;&gt;
decompress_sample_data(compression, data, ...) -&gt; Result&lt;DeepSamples&gt;
<span class="boring">}</span></code></pre>
<h3 id="piz-improvements"><a class="header" href="#piz-improvements">PIZ Improvements</a></h3>
<ul>
<li>Fixed overflow bugs in Huffman coding</li>
<li>Improved error handling</li>
<li>Better bit manipulation</li>
<li>+274 lines in <code>huffman.rs</code></li>
<li>+152 lines in <code>wavelet.rs</code></li>
</ul>
<h3 id="b44-optimizations"><a class="header" href="#b44-optimizations">B44 Optimizations</a></h3>
<ul>
<li>+10,928 lines of expanded lookup tables</li>
<li>Faster encoding via precomputed values</li>
<li>Better cache utilization</li>
</ul>
<h3 id="general-compression"><a class="header" href="#general-compression">General Compression</a></h3>
<ul>
<li>Reduced allocations in hot paths</li>
<li>Better memory locality</li>
<li>Deep-aware byte reordering</li>
</ul>
<h2 id="block-layer-improvements"><a class="header" href="#block-layer-improvements">Block Layer Improvements</a></h2>
<h3 id="chunk-processing-srcblockchunkrs"><a class="header" href="#chunk-processing-srcblockchunkrs">Chunk Processing (<code>src/block/chunk.rs</code>)</a></h3>
<p>+175 lines:</p>
<ul>
<li>Deep chunk type support</li>
<li>Enhanced validation</li>
<li>Improved error messages</li>
</ul>
<h3 id="lines-processing-srcblocklinesrs"><a class="header" href="#lines-processing-srcblocklinesrs">Lines Processing (<code>src/block/lines.rs</code>)</a></h3>
<p>+100 lines:</p>
<ul>
<li>Subsampling considerations</li>
<li>Deep line handling</li>
</ul>
<h3 id="sample-handling-srcblocksamplesrs"><a class="header" href="#sample-handling-srcblocksamplesrs">Sample Handling (<code>src/block/samples.rs</code>)</a></h3>
<p>+189 lines:</p>
<ul>
<li>Deep sample types</li>
<li>Type conversion improvements</li>
</ul>
<h3 id="reader-srcblockreaderrs"><a class="header" href="#reader-srcblockreaderrs">Reader (<code>src/block/reader.rs</code>)</a></h3>
<p>+363 lines:</p>
<ul>
<li>Deep block reading</li>
<li>Improved parallelization</li>
<li>Better chunk iteration</li>
</ul>
<h3 id="writer-srcblockwriterrs"><a class="header" href="#writer-srcblockwriterrs">Writer (<code>src/block/writer.rs</code>)</a></h3>
<p>+306 lines:</p>
<ul>
<li>Deep block writing</li>
<li>Better chunk generation</li>
<li>Offset table handling</li>
</ul>
<h2 id="metadata-improvements"><a class="header" href="#metadata-improvements">Metadata Improvements</a></h2>
<h3 id="attributes-srcmetaattributers"><a class="header" href="#attributes-srcmetaattributers">Attributes (<code>src/meta/attribute.rs</code>)</a></h3>
<p>+956 lines:</p>
<ul>
<li>New attribute types for deep data</li>
<li>Enhanced validation</li>
<li>Improved parsing edge cases</li>
</ul>
<h3 id="headers-srcmetaheaderrs"><a class="header" href="#headers-srcmetaheaderrs">Headers (<code>src/meta/header.rs</code>)</a></h3>
<p>+824 lines:</p>
<ul>
<li>Deep data header support</li>
<li><code>TileIndices</code> Ord/PartialOrd implementation</li>
<li>Better level iteration</li>
<li>Enhanced validation</li>
</ul>
<h3 id="meta-module-srcmetamodrs"><a class="header" href="#meta-module-srcmetamodrs">Meta Module (<code>src/meta/mod.rs</code>)</a></h3>
<p>+547 lines:</p>
<ul>
<li>Deep metadata structures</li>
<li>Version handling improvements</li>
<li>Better error messages</li>
</ul>
<h2 id="image-module-improvements"><a class="header" href="#image-module-improvements">Image Module Improvements</a></h2>
<h3 id="crop-operations-srcimagecroprs"><a class="header" href="#crop-operations-srcimagecroprs">Crop Operations (<code>src/image/crop.rs</code>)</a></h3>
<p>+698 lines:</p>
<ul>
<li>Deep image cropping support</li>
<li>Better bounds checking</li>
<li>Optimized memory handling</li>
</ul>
<h3 id="channel-operations"><a class="header" href="#channel-operations">Channel Operations</a></h3>
<p>Various improvements:</p>
<ul>
<li><code>write/channels.rs</code>: +323 lines</li>
<li><code>write/layers.rs</code>: +131 lines</li>
<li><code>write/samples.rs</code>: +134 lines</li>
<li><code>read/specific_channels.rs</code>: +350 lines</li>
</ul>
<h2 id="io-improvements-srciors"><a class="header" href="#io-improvements-srciors">I/O Improvements (<code>src/io.rs</code>)</a></h2>
<p>+151 lines:</p>
<ul>
<li>Better seeking</li>
<li>Overflow protection</li>
<li>Improved error handling</li>
</ul>
<h2 id="math-utilities-srcmathrs"><a class="header" href="#math-utilities-srcmathrs">Math Utilities (<code>src/math.rs</code>)</a></h2>
<p>+100 lines:</p>
<ul>
<li>Better vector operations</li>
<li>Overflow-safe arithmetic</li>
</ul>
<h2 id="dead-code-cleanup"><a class="header" href="#dead-code-cleanup">Dead Code Cleanup</a></h2>
<p>Systematic audit and cleanup:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Item</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><code>TileIndices::cmp</code></td><td>Ord/PartialOrd implemented</td></tr>
<tr><td><code>for_lines</code> unused</td><td>Deleted</td></tr>
<tr><td>Duplicate <code>enumerate_ordered_blocks</code></td><td>Deleted</td></tr>
<tr><td><code>ordered_block_indices</code></td><td>Implemented + tests</td></tr>
<tr><td><code>pixel_section_indices</code></td><td>Implemented + 6 tests</td></tr>
<tr><td><code>AnySamplesReader</code></td><td>Roundtrip tested</td></tr>
<tr><td><code>specific_resolution_level</code></td><td>10 tests</td></tr>
<tr><td><code>all_valid_layers</code></td><td>5 tests</td></tr>
<tr><td><code>validate_results</code></td><td><code>#[cfg(test)]</code> added</td></tr>
</tbody>
</table>
</div>
<p><strong>Result:</strong> 9/11 items completed, 2 deferred (Rust limitations)</p>
<h2 id="test-improvements"><a class="header" href="#test-improvements">Test Improvements</a></h2>
<h3 id="new-test-files"><a class="header" href="#new-test-files">New Test Files</a></h3>
<ol>
<li><strong>deep_read.rs</strong> - 176 lines of deep reading tests</li>
<li><strong>deep_benchmark.rs</strong> - 61 lines of performance benchmarks</li>
</ol>
<h3 id="enhanced-tests"><a class="header" href="#enhanced-tests">Enhanced Tests</a></h3>
<ul>
<li><code>roundtrip.rs</code>: +216 lines (deep roundtrip)</li>
<li><code>fuzz.rs</code>: +185 lines (deep fuzzing)</li>
<li><code>across_compression.rs</code>: +59 lines</li>
</ul>
<h3 id="test-data"><a class="header" href="#test-data">Test Data</a></h3>
<p>Added official OpenEXR deep test images (~17MB):</p>
<ul>
<li>MiniCooper720p.exr</li>
<li>PiranhnaAlienRun720p.exr</li>
<li>Teaset720p.exr</li>
</ul>
<h2 id="examples-updates"><a class="header" href="#examples-updates">Examples Updates</a></h2>
<p>All examples updated:</p>
<ul>
<li>Consistent error handling</li>
<li>Deep data awareness</li>
<li>Modern Rust idioms</li>
<li>~700 lines of improvements</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<h3 id="new-files"><a class="header" href="#new-files">New Files</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Lines</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>DEEP.md</td><td>342</td><td>Deep data format explanation</td></tr>
<tr><td>DEAD_CODE_ANALYSIS.md</td><td>509</td><td>Code quality audit</td></tr>
<tr><td>AGENTS.md</td><td>556</td><td>Architecture documentation</td></tr>
</tbody>
</table>
</div>
<h3 id="updated-files"><a class="header" href="#updated-files">Updated Files</a></h3>
<ul>
<li>README.md: +14 lines (deep data mention)</li>
<li>GUIDE.md: +163 lines (deep data section)</li>
</ul>
<h2 id="performance-summary"><a class="header" href="#performance-summary">Performance Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Area</th><th>Improvement</th></tr>
</thead>
<tbody>
<tr><td>Deep parallel read</td><td>1.5-2.5x speedup</td></tr>
<tr><td>B44 encoding</td><td>Faster via lookup tables</td></tr>
<tr><td>PIZ compression</td><td>Reduced allocations</td></tr>
<tr><td>Block iteration</td><td>Better cache usage</td></tr>
</tbody>
</table>
</div>
<h2 id="api-additions"><a class="header" href="#api-additions">API Additions</a></h2>
<h3 id="new-functions"><a class="header" href="#new-functions">New Functions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unified reading
pub fn read_first_any_layer_from_file(path) -&gt; Result&lt;AnyImage&gt;

// Deep reading  
pub fn read_first_deep_layer_from_file(path) -&gt; Result&lt;DeepImage&gt;

// Level selection (builder method)
fn specific_resolution_level(selector) -&gt; ReadSpecificLevel

// Valid layers (builder method)
fn all_valid_layers() -&gt; ReadAllValidLayers
<span class="boring">}</span></code></pre>
<h3 id="new-types"><a class="header" href="#new-types">New Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Deep data
pub struct DeepSamples { ... }
pub enum DeepChannelData { F16, F32, U32 }

// Unified
pub enum DeepAndFlatSamples { Deep(DeepSamples), Flat(FlatSamples) }

// Level info
pub struct LevelInfo { pub index: Vec2&lt;usize&gt;, pub resolution: Vec2&lt;usize&gt; }
<span class="boring">}</span></code></pre>
<h3 id="new-builder-methods"><a class="header" href="#new-builder-methods">New Builder Methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ReadBuilder {
    fn flat_and_deep_data(self) -&gt; ReadAnySamples  // NEW
    fn any_deep_data(self) -&gt; ReadDeepSamples      // NEW
}

impl ReadFlatSamples {
    fn specific_resolution_level&lt;F&gt;(self, selector: F) -&gt; ReadSpecificLevel  // NEW
}

impl ReadChannels {
    fn all_valid_layers(self) -&gt; ReadAllValidLayers  // NEW
}
<span class="boring">}</span></code></pre>
<h2 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards Compatibility</a></h2>
<p><strong>All changes are backwards compatible.</strong> Existing code continues to work without modification.</p>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="#deep-data-support">Deep Data Support</a> - Deep-specific enhancements</li>
<li><a href="#architecture-overview">Developer Guide</a> - Internal architecture</li>
<li><a href="#prelude">API Reference</a> - Full API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>This document describes the high-level architecture of the exrs library.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<h3 id="safety-first"><a class="header" href="#safety-first">Safety First</a></h3>
<p>The library uses no unsafe code:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![forbid(unsafe_code)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>All operations are bounds-checked, and allocations have safe maximum sizes to prevent memory exhaustion attacks.</p>
<h3 id="layered-abstraction"><a class="header" href="#layered-abstraction">Layered Abstraction</a></h3>
<pre><code>┌─────────────────────────────────────────┐
│           User Code                      │
├─────────────────────────────────────────┤
│    High-Level Image API (image/)         │  ← Most users stop here
├─────────────────────────────────────────┤
│    Block API (block/)                    │  ← For custom processing
├─────────────────────────────────────────┤
│    Metadata (meta/)                      │  ← Headers, attributes
├─────────────────────────────────────────┤
│    Compression (compression/)            │  ← Algorithm implementations
├─────────────────────────────────────────┤
│    I/O Utilities (io.rs)                 │  ← Reading/writing primitives
└─────────────────────────────────────────┘
</code></pre>
<h3 id="type-driven-api"><a class="header" href="#type-driven-api">Type-Driven API</a></h3>
<p>The image type reflects your choices at compile time:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Your choices...
read()
    .no_deep_data()           // FlatSamples vs DeepSamples
    .largest_resolution_level() // vs Levels&lt;&gt;
    .all_channels()           // AnyChannels vs SpecificChannels
    .first_valid_layer()      // Layer vs Layers
    .all_attributes()

// ...determine the result type
Image&lt;Layer&lt;AnyChannels&lt;FlatSamples&gt;&gt;&gt;
<span class="boring">}</span></code></pre>
<h2 id="module-structure"><a class="header" href="#module-structure">Module Structure</a></h2>
<pre><code>exrs/
├── lib.rs              # Entry point, prelude exports
├── error.rs            # Error types (Error, Result, UnitResult)
├── math.rs             # Vec2&lt;T&gt;, RoundingMode
├── io.rs               # PeekRead, Tracking, Data trait
│
├── meta/               # File metadata
│   ├── mod.rs          # MetaData, Requirements, BlockDescription
│   ├── header.rs       # Header, ImageAttributes, LayerAttributes
│   └── attribute.rs    # ChannelList, Compression, Text, etc.
│
├── block/              # Low-level block I/O
│   ├── mod.rs          # BlockIndex, UncompressedBlock
│   ├── reader.rs       # Reader&lt;R&gt;, ChunksReader
│   ├── writer.rs       # ChunkWriter&lt;W&gt;, ChunksWriter
│   ├── chunk.rs        # Chunk, CompressedBlock variants
│   ├── lines.rs        # LineIndex, LineRef, LineRefMut
│   ├── samples.rs      # Sample enum (F16/F32/U32)
│   └── deep.rs         # DeepUncompressedBlock, decompressors
│
├── compression/        # Compression algorithms
│   ├── mod.rs          # Compression enum, dispatch
│   ├── rle.rs          # Run-length encoding
│   ├── zip.rs          # ZIP (miniz_oxide + zune-inflate)
│   ├── pxr24.rs        # PXR24 (float24 + ZIP)
│   ├── piz/            # PIZ compression
│   │   ├── mod.rs
│   │   ├── wavelet.rs
│   │   └── huffman.rs
│   └── b44/            # B44/B44A compression
│       ├── mod.rs
│       └── table.rs
│
└── image/              # High-level image API
    ├── mod.rs          # Image, Layer, Encoding, Channels
    ├── deep.rs         # DeepSamples, DeepChannelData
    ├── crop.rs         # Cropping utilities
    ├── pixel_vec.rs    # Simple pixel storage
    ├── recursive.rs    # Recursive type helpers
    ├── channel_groups.rs
    │
    ├── read/           # Reading pipeline
    │   ├── mod.rs      # read(), convenience functions
    │   ├── image.rs    # ReadImage trait
    │   ├── layers.rs   # Layer reading
    │   ├── levels.rs   # Resolution level reading
    │   ├── samples.rs  # Sample reading
    │   ├── any_channels.rs
    │   ├── specific_channels.rs
    │   ├── any_samples.rs  # Unified deep/flat
    │   └── deep.rs     # Deep-specific reading
    │
    └── write/          # Writing pipeline
        ├── mod.rs      # WritableImage trait
        ├── layers.rs
        ├── channels.rs
        ├── samples.rs
        └── deep.rs     # Deep-specific writing
</code></pre>
<h2 id="key-abstractions"><a class="header" href="#key-abstractions">Key Abstractions</a></h2>
<h3 id="imagelayers"><a class="header" href="#imagelayers">Image&lt;Layers&gt;</a></h3>
<p>The top-level container:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Image&lt;Layers&gt; {
    pub attributes: ImageAttributes,
    pub layer_data: Layers,
}
<span class="boring">}</span></code></pre>
<p><code>Layers</code> can be:</p>
<ul>
<li><code>Layer&lt;Channels&gt;</code> - Single layer</li>
<li><code>Layers&lt;Channels&gt;</code> (SmallVec) - Multiple layers</li>
</ul>
<h3 id="layerchannels"><a class="header" href="#layerchannels">Layer&lt;Channels&gt;</a></h3>
<p>A single image layer:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Layer&lt;Channels&gt; {
    pub channel_data: Channels,
    pub attributes: LayerAttributes,
    pub size: Vec2&lt;usize&gt;,
    pub encoding: Encoding,
}
<span class="boring">}</span></code></pre>
<h3 id="channels"><a class="header" href="#channels">Channels</a></h3>
<p>Two variants:</p>
<p><strong>SpecificChannels</strong> - Known channels at compile time:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SpecificChannels&lt;Pixels, ChannelDescriptions&gt; {
    pub channels: ChannelDescriptions,  // (R, G, B, A) descriptions
    pub pixels: Pixels,                  // Your storage
}
<span class="boring">}</span></code></pre>
<p><strong>AnyChannels</strong> - Dynamic channel list:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnyChannels&lt;Samples&gt; {
    pub list: SmallVec&lt;[AnyChannel&lt;Samples&gt;; 4]&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="samples"><a class="header" href="#samples">Samples</a></h3>
<p>Flat samples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FlatSamples {
    F16(Vec&lt;f16&gt;),
    F32(Vec&lt;f32&gt;),
    U32(Vec&lt;u32&gt;),
}
<span class="boring">}</span></code></pre>
<p>Deep samples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DeepSamples {
    pub sample_offsets: Vec&lt;u32&gt;,
    pub channels: Vec&lt;DeepChannelData&gt;,
    pub width: usize,
    pub height: usize,
}
<span class="boring">}</span></code></pre>
<h3 id="encoding"><a class="header" href="#encoding">Encoding</a></h3>
<p>How pixels are stored:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Encoding {
    pub compression: Compression,
    pub blocks: Blocks,
    pub line_order: LineOrder,
}
<span class="boring">}</span></code></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Error {
    NotSupported(Cow&lt;'static, str&gt;),  // Feature not implemented
    Invalid(Cow&lt;'static, str&gt;),       // Malformed data
    Io(IoError),                      // I/O errors
    Aborted,                          // Operation cancelled
}

pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;
pub type UnitResult = Result&lt;()&gt;;
<span class="boring">}</span></code></pre>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p>The library is designed for parallel processing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Reading: parallel decompression
read()
    .no_deep_data()
    // ... options ...
    .from_file("image.exr")  // Uses rayon internally

// Writing: parallel compression
image.write()
    .to_file("output.exr")   // Uses rayon internally

// Disable if needed
.non_parallel()
<span class="boring">}</span></code></pre>
<p>Parallelism is opt-out via the <code>rayon</code> feature flag.</p>
<h2 id="memory-strategy"><a class="header" href="#memory-strategy">Memory Strategy</a></h2>
<h3 id="allocation-limits"><a class="header" href="#allocation-limits">Allocation Limits</a></h3>
<p>To prevent memory exhaustion:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_ALLOCATION_SIZE: usize = 1024 * 1024 * 1024;  // 1 GB
<span class="boring">}</span></code></pre>
<h3 id="smallvec-usage"><a class="header" href="#smallvec-usage">SmallVec Usage</a></h3>
<p>For common small collections:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Layers&lt;C&gt; = SmallVec&lt;[Layer&lt;C&gt;; 2]&gt;;
pub type ChannelList = SmallVec&lt;[AnyChannel; 4]&gt;;
<span class="boring">}</span></code></pre>
<h3 id="zero-copy-where-possible"><a class="header" href="#zero-copy-where-possible">Zero-Copy Where Possible</a></h3>
<p>The reader uses <code>std::io::Read</code> trait, allowing:</p>
<ul>
<li>Memory-mapped files</li>
<li>Network streams</li>
<li>In-memory buffers</li>
</ul>
<h2 id="extension-points"><a class="header" href="#extension-points">Extension Points</a></h2>
<h3 id="custom-pixel-storage"><a class="header" href="#custom-pixel-storage">Custom Pixel Storage</a></h3>
<p>Implement <code>GetPixel</code> for writing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait GetPixel {
    type Pixel;
    fn get_pixel(&amp;self, position: Vec2&lt;usize&gt;) -&gt; Self::Pixel;
}
<span class="boring">}</span></code></pre>
<h3 id="custom-attribute-types"><a class="header" href="#custom-attribute-types">Custom Attribute Types</a></h3>
<p>Use <code>AttributeValue::Custom</code> for unknown types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AttributeValue::Custom {
    type_name: Text,
    bytes: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="low-level-block-access"><a class="header" href="#low-level-block-access">Low-Level Block Access</a></h3>
<p>For custom processing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::block;

// Read blocks directly
let reader = block::read(...)?;
for chunk in reader.all_chunks(pedantic) {
    let block = UncompressedBlock::decompress_chunk(chunk?, &amp;meta, pedantic)?;
    // Custom processing
}
<span class="boring">}</span></code></pre>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="#module-structure-1">Module Structure</a> - Detailed module documentation</li>
<li><a href="#data-flow-1">Data Flow</a> - How data moves through the library</li>
<li><a href="#compression-algorithms">Compression</a> - Compression algorithm details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="module-structure-1"><a class="header" href="#module-structure-1">Module Structure</a></h1>
<p>Detailed documentation of each module in exrs.</p>
<h2 id="librs---entry-point"><a class="header" href="#librs---entry-point"><code>lib.rs</code> - Entry Point</a></h2>
<p>The crate root exports:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod io;           // I/O primitives
pub mod compression;  // Compression algorithms
pub mod image;        // High-level API
pub mod math;         // Vec2, etc.
pub mod meta;         // Metadata types
pub mod block;        // Low-level blocks
pub mod error;        // Error types

pub mod prelude;      // Convenient re-exports
<span class="boring">}</span></code></pre>
<h2 id="errorrs---error-types"><a class="header" href="#errorrs---error-types"><code>error.rs</code> - Error Types</a></h2>
<h3 id="error-enum"><a class="header" href="#error-enum">Error Enum</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Error {
    /// Feature not yet implemented
    NotSupported(Cow&lt;'static, str&gt;),
    
    /// Invalid/malformed data
    Invalid(Cow&lt;'static, str&gt;),
    
    /// I/O error (wraps std::io::Error)
    Io(IoError),
    
    /// Operation aborted
    Aborted,
}
<span class="boring">}</span></code></pre>
<h3 id="helper-functions"><a class="header" href="#helper-functions">Helper Functions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn usize_to_i32(value: usize, name: &amp;str) -&gt; Result&lt;i32&gt;
pub fn i32_to_usize(value: i32, name: &amp;str) -&gt; Result&lt;usize&gt;
<span class="boring">}</span></code></pre>
<h2 id="mathrs---math-utilities"><a class="header" href="#mathrs---math-utilities"><code>math.rs</code> - Math Utilities</a></h2>
<h3 id="vec2"><a class="header" href="#vec2">Vec2</a></h3>
<p>Generic 2D vector:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vec2&lt;T&gt;(pub T, pub T);

impl&lt;T&gt; Vec2&lt;T&gt; {
    pub fn x(&amp;self) -&gt; T;
    pub fn y(&amp;self) -&gt; T;
    pub fn width(&amp;self) -&gt; T;   // Alias for x
    pub fn height(&amp;self) -&gt; T;  // Alias for y
    pub fn area(&amp;self) -&gt; T;    // x * y
}
<span class="boring">}</span></code></pre>
<h3 id="roundingmode"><a class="header" href="#roundingmode">RoundingMode</a></h3>
<p>For mipmap calculations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum RoundingMode {
    Up,
    Down,
}
<span class="boring">}</span></code></pre>
<h2 id="iors---io-utilities"><a class="header" href="#iors---io-utilities"><code>io.rs</code> - I/O Utilities</a></h2>
<h3 id="peekread"><a class="header" href="#peekread">PeekRead</a></h3>
<p>Buffered reading with peek:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PeekRead: Read {
    fn peek(&amp;mut self, count: usize) -&gt; &amp;[u8];
}
<span class="boring">}</span></code></pre>
<h3 id="tracking"><a class="header" href="#tracking">Tracking</a></h3>
<p>Tracks bytes read/written:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Tracking&lt;T&gt; {
    inner: T,
    position: u64,
}
<span class="boring">}</span></code></pre>
<h3 id="data-trait"><a class="header" href="#data-trait">Data Trait</a></h3>
<p>Binary serialization:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Data: Sized {
    fn read(read: &amp;mut impl Read) -&gt; Result&lt;Self&gt;;
    fn write(&amp;self, write: &amp;mut impl Write) -&gt; UnitResult;
}
<span class="boring">}</span></code></pre>
<h2 id="meta---metadata"><a class="header" href="#meta---metadata"><code>meta/</code> - Metadata</a></h2>
<h3 id="metamodrs"><a class="header" href="#metamodrs"><code>meta/mod.rs</code></a></h3>
<p>Core metadata types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MetaData {
    pub requirements: Requirements,
    pub headers: Headers,
}

pub struct Requirements {
    pub file_format_version: u8,
    pub is_single_part: bool,
    pub has_deep_data: bool,
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="metaheaderrs"><a class="header" href="#metaheaderrs"><code>meta/header.rs</code></a></h3>
<p>Header structures:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Header {
    pub channels: ChannelList,
    pub compression: Compression,
    pub data_size: Vec2&lt;usize&gt;,
    pub blocks: BlockDescription,
    pub layer_attributes: LayerAttributes,
    pub shared_attributes: Option&lt;Arc&lt;ImageAttributes&gt;&gt;,
    // ...
}

pub struct ImageAttributes {
    pub display_window: IntegerBounds,
    pub pixel_aspect: f32,
    pub chromaticities: Option&lt;Chromaticities&gt;,
    pub time_code: Option&lt;TimeCode&gt;,
    pub other: HashMap&lt;Text, AttributeValue&gt;,
}

pub struct LayerAttributes {
    pub layer_name: Option&lt;Text&gt;,
    pub owner: Option&lt;Text&gt;,
    pub comments: Option&lt;Text&gt;,
    pub software_name: Option&lt;Text&gt;,
    // ...many more
}
<span class="boring">}</span></code></pre>
<h3 id="metaattributers"><a class="header" href="#metaattributers"><code>meta/attribute.rs</code></a></h3>
<p>Attribute types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Text(SmallVec&lt;[u8; 24]&gt;);  // UTF-8 string

pub enum Compression {
    Uncompressed,
    RLE,
    ZIPS,
    ZIP,
    PIZ,
    PXR24,
    B44,
    B44A,
    DWAA,
    DWAB,
}

pub enum SampleType {
    U32,
    F16,
    F32,
}

pub struct ChannelDescription {
    pub name: Text,
    pub sample_type: SampleType,
    pub quantize_linearly: bool,
    pub sampling: Vec2&lt;usize&gt;,
}

pub enum AttributeValue {
    I32(i32),
    F32(f32),
    F64(f64),
    Text(Text),
    // ... many more
    Custom { type_name: Text, bytes: Vec&lt;u8&gt; },
}
<span class="boring">}</span></code></pre>
<h2 id="block---block-io"><a class="header" href="#block---block-io"><code>block/</code> - Block I/O</a></h2>
<h3 id="blockmodrs"><a class="header" href="#blockmodrs"><code>block/mod.rs</code></a></h3>
<p>Core block types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BlockIndex {
    pub layer: usize,
    pub level: Vec2&lt;usize&gt;,
    pub pixel_position: Vec2&lt;usize&gt;,
    pub pixel_size: Vec2&lt;usize&gt;,
}

pub struct UncompressedBlock {
    pub index: BlockIndex,
    pub data: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="blockchunkrs"><a class="header" href="#blockchunkrs"><code>block/chunk.rs</code></a></h3>
<p>Compressed chunks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Chunk {
    pub layer_index: usize,
    pub compressed_block: CompressedBlock,
}

pub enum CompressedBlock {
    ScanLine { y: i32, data: Vec&lt;u8&gt; },
    Tile { position: Vec2&lt;usize&gt;, level: Vec2&lt;usize&gt;, data: Vec&lt;u8&gt; },
    DeepScanLine { y: i32, sample_table: Vec&lt;u8&gt;, sample_data: Vec&lt;u8&gt; },
    DeepTile { ... },
}
<span class="boring">}</span></code></pre>
<h3 id="blockreaderrs"><a class="header" href="#blockreaderrs"><code>block/reader.rs</code></a></h3>
<p>Reading:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Reader&lt;R&gt; {
    meta_data: MetaData,
    read: R,
    // ...
}

impl&lt;R: Read + Seek&gt; Reader&lt;R&gt; {
    pub fn read_from_file(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self&gt;;
    pub fn read_from_buffered(read: R, pedantic: bool) -&gt; Result&lt;Self&gt;;
    pub fn all_chunks(self, pedantic: bool) -&gt; ChunksReader&lt;R&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="blockwriterrs"><a class="header" href="#blockwriterrs"><code>block/writer.rs</code></a></h3>
<p>Writing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn write&lt;W: Write + Seek&gt;(
    write: W,
    headers: Headers,
    write_chunks: impl FnOnce(MetaData, &amp;mut ChunksWriter&lt;W&gt;) -&gt; UnitResult,
) -&gt; UnitResult;
<span class="boring">}</span></code></pre>
<h3 id="blocklinesrs"><a class="header" href="#blocklinesrs"><code>block/lines.rs</code></a></h3>
<p>Line access:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LineIndex {
    pub channel: usize,
    pub position: Vec2&lt;usize&gt;,
}

pub struct LineRef&lt;'a&gt; {
    pub index: LineIndex,
    pub data: &amp;'a [u8],
}
<span class="boring">}</span></code></pre>
<h3 id="blocksamplesrs"><a class="header" href="#blocksamplesrs"><code>block/samples.rs</code></a></h3>
<p>Sample types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Sample {
    F16(f16),
    F32(f32),
    U32(u32),
}
<span class="boring">}</span></code></pre>
<h3 id="blockdeeprs"><a class="header" href="#blockdeeprs"><code>block/deep.rs</code></a></h3>
<p>Deep block processing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DeepUncompressedBlock {
    pub index: BlockIndex,
    pub samples: DeepSamples,
}

pub fn decompress_deep_scanline_block(...) -&gt; Result&lt;DeepUncompressedBlock&gt;;
pub fn decompress_deep_tile_block(...) -&gt; Result&lt;DeepUncompressedBlock&gt;;
<span class="boring">}</span></code></pre>
<h2 id="compression---algorithms"><a class="header" href="#compression---algorithms"><code>compression/</code> - Algorithms</a></h2>
<h3 id="compressionmodrs"><a class="header" href="#compressionmodrs"><code>compression/mod.rs</code></a></h3>
<p>Dispatch:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Compression {
    pub fn compress_image_section_to_le(&amp;self, ...) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
    pub fn decompress_image_section_from_le(&amp;self, ...) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
}

// Pre/post processing
fn separate_bytes_fragments(bytes: &amp;mut [u8]);
fn interleave_byte_blocks(bytes: &amp;mut [u8]);
fn samples_to_differences(bytes: &amp;mut [u8]);
fn differences_to_samples(bytes: &amp;mut [u8]);
<span class="boring">}</span></code></pre>
<h3 id="compressionrlers"><a class="header" href="#compressionrlers"><code>compression/rle.rs</code></a></h3>
<p>Run-length encoding:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compress(uncompressed: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
pub fn decompress(compressed: &amp;[u8], expected_size: usize) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
<span class="boring">}</span></code></pre>
<h3 id="compressionziprs"><a class="header" href="#compressionziprs"><code>compression/zip.rs</code></a></h3>
<p>ZIP compression (using miniz_oxide + zune-inflate):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compress(uncompressed: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
pub fn decompress(compressed: &amp;[u8], expected_size: usize) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
<span class="boring">}</span></code></pre>
<h3 id="compressionpxr24rs"><a class="header" href="#compressionpxr24rs"><code>compression/pxr24.rs</code></a></h3>
<p>PXR24 (24-bit float):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compress(channels: &amp;ChannelList, uncompressed: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
pub fn decompress(channels: &amp;ChannelList, compressed: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
<span class="boring">}</span></code></pre>
<h3 id="compressionpiz"><a class="header" href="#compressionpiz"><code>compression/piz/</code></a></h3>
<p>PIZ compression (Huffman + wavelet):</p>
<ul>
<li><code>mod.rs</code> - Main compress/decompress</li>
<li><code>huffman.rs</code> - Huffman coding</li>
<li><code>wavelet.rs</code> - Haar wavelet transform</li>
</ul>
<h3 id="compressionb44"><a class="header" href="#compressionb44"><code>compression/b44/</code></a></h3>
<p>B44 block compression:</p>
<ul>
<li><code>mod.rs</code> - Block processing</li>
<li><code>table.rs</code> - Lookup tables (10,928 lines)</li>
</ul>
<h2 id="image---high-level-api"><a class="header" href="#image---high-level-api"><code>image/</code> - High-Level API</a></h2>
<h3 id="imagemodrs"><a class="header" href="#imagemodrs"><code>image/mod.rs</code></a></h3>
<p>Core types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Image&lt;Layers&gt; {
    pub attributes: ImageAttributes,
    pub layer_data: Layers,
}

pub struct Layer&lt;Channels&gt; {
    pub channel_data: Channels,
    pub attributes: LayerAttributes,
    pub size: Vec2&lt;usize&gt;,
    pub encoding: Encoding,
}

pub struct Encoding {
    pub compression: Compression,
    pub blocks: Blocks,
    pub line_order: LineOrder,
}
<span class="boring">}</span></code></pre>
<h3 id="imagedeeprs"><a class="header" href="#imagedeeprs"><code>image/deep.rs</code></a></h3>
<p>Deep data types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DeepSamples {
    pub sample_offsets: Vec&lt;u32&gt;,
    pub channels: Vec&lt;DeepChannelData&gt;,
    pub width: usize,
    pub height: usize,
}

impl DeepSamples {
    pub fn total_samples(&amp;self) -&gt; usize;
    pub fn sample_count(&amp;self, x: usize, y: usize) -&gt; usize;
    pub fn sample_range(&amp;self, pixel_idx: usize) -&gt; (usize, usize);
    pub fn max_samples_per_pixel(&amp;self) -&gt; usize;
}
<span class="boring">}</span></code></pre>
<h3 id="imageread"><a class="header" href="#imageread"><code>image/read/</code></a></h3>
<p>Reading pipeline:</p>
<ul>
<li><code>mod.rs</code> - <code>read()</code> entry point, convenience functions</li>
<li><code>image.rs</code> - <code>ReadImage</code> trait</li>
<li><code>layers.rs</code> - Layer reading</li>
<li><code>levels.rs</code> - Resolution levels, <code>LevelInfo</code></li>
<li><code>samples.rs</code> - Sample reading</li>
<li><code>any_channels.rs</code> - Dynamic channels</li>
<li><code>specific_channels.rs</code> - Static channels</li>
<li><code>any_samples.rs</code> - Unified deep/flat</li>
<li><code>deep.rs</code> - Deep-specific reading</li>
</ul>
<h3 id="imagewrite"><a class="header" href="#imagewrite"><code>image/write/</code></a></h3>
<p>Writing pipeline:</p>
<ul>
<li><code>mod.rs</code> - <code>WritableImage</code> trait</li>
<li><code>layers.rs</code> - Layer writing</li>
<li><code>channels.rs</code> - Channel writing</li>
<li><code>samples.rs</code> - Sample writing</li>
<li><code>deep.rs</code> - Deep-specific writing</li>
</ul>
<h3 id="imagecroprs"><a class="header" href="#imagecroprs"><code>image/crop.rs</code></a></h3>
<p>Cropping utilities:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Crop&lt;Sample&gt; {
    type Cropped;
    fn crop(self, crop_where: impl FnMut(&amp;Sample) -&gt; bool) -&gt; CropResult&lt;Self::Cropped&gt;;
}

pub enum CropResult&lt;T&gt; {
    Cropped { result: T, data_window_offset: Vec2&lt;i32&gt; },
    Empty,
}
<span class="boring">}</span></code></pre>
<h3 id="imagepixel_vecrs"><a class="header" href="#imagepixel_vecrs"><code>image/pixel_vec.rs</code></a></h3>
<p>Simple pixel storage:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PixelVec&lt;Pixel&gt; {
    pub resolution: Vec2&lt;usize&gt;,
    pub pixels: Vec&lt;Pixel&gt;,
}
<span class="boring">}</span></code></pre>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See Also</a></h2>
<ul>
<li><a href="#architecture-overview">Architecture Overview</a> - High-level design</li>
<li><a href="#data-flow-1">Data Flow</a> - How data moves through modules</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="data-flow-1"><a class="header" href="#data-flow-1">Data Flow</a></h1>
<p>How data moves through exrs when reading and writing EXR files.</p>
<h2 id="reading-pipeline"><a class="header" href="#reading-pipeline">Reading Pipeline</a></h2>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<pre><code>File/Bytes → Metadata → Chunks → Decompress → Blocks → Lines → Image
</code></pre>
<h3 id="detailed-flow"><a class="header" href="#detailed-flow">Detailed Flow</a></h3>
<pre><code>┌──────────────────────────────────────────────────────────────────────┐
│                           USER CODE                                   │
│  read().no_deep_data().all_channels().first_valid_layer()...         │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                         image/read/mod.rs                             │
│                                                                       │
│  ReadBuilder → ReadFlatSamples → ReadChannels → ReadLayers → Read    │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                         block/reader.rs                               │
│                                                                       │
│  Reader::read_from_buffered(read, pedantic)                          │
│    1. Validate magic number (0x762f3101)                             │
│    2. Read Requirements (version, flags)                              │
│    3. Read Headers (one per layer)                                    │
│    4. Read/Skip OffsetTables                                          │
│                                                                       │
│  reader.all_chunks(pedantic) → ChunksReader                          │
│    - Iterator over Chunk (compressed blocks)                          │
│    - Validates offsets                                                │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    ▼                               ▼
            ┌─────────────┐                 ┌─────────────┐
            │ Sequential  │                 │  Parallel   │
            │   Reading   │                 │  (rayon)    │
            └─────────────┘                 └─────────────┘
                    │                               │
                    └───────────────┬───────────────┘
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                       compression/mod.rs                              │
│                                                                       │
│  Compression::decompress_image_section_from_le()                     │
│                                                                       │
│    match compression {                                                │
│      Uncompressed =&gt; convert endianness                               │
│      RLE          =&gt; rle::decompress()                                │
│      ZIP/ZIPS     =&gt; zip::decompress()                                │
│      PIZ          =&gt; piz::decompress()                                │
│      PXR24        =&gt; pxr24::decompress()                              │
│      B44/B44A     =&gt; b44::decompress()                                │
│    }                                                                  │
│                                                                       │
│  Post-processing:                                                     │
│    differences_to_samples() - undo delta encoding                     │
│    interleave_byte_blocks() - reorder bytes                           │
│    little-endian → native-endian                                      │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                          block/mod.rs                                 │
│                                                                       │
│  UncompressedBlock::decompress_chunk(chunk, meta, pedantic)          │
│    Returns: UncompressedBlock { index, data: Vec&lt;u8&gt; }               │
│                                                                       │
│  block.lines(channels) → Iterator&lt;LineRef&gt;                           │
│    Yields lines for each channel, each scan line                      │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                 image/read/specific_channels.rs                       │
│                                                                       │
│  SpecificChannelsReader::filter_block()                              │
│    - Reads line samples into user storage                             │
│    - Calls user's set_pixel() callback                                │
│    - Converts sample types as needed                                  │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                          ┌───────────────────┐
                          │  Image&lt;Layers&gt;    │
                          │  (User receives)  │
                          └───────────────────┘
</code></pre>
<h2 id="writing-pipeline"><a class="header" href="#writing-pipeline">Writing Pipeline</a></h2>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<pre><code>Image → Blocks → Lines → Compress → Chunks → Metadata → File
</code></pre>
<h3 id="detailed-flow-1"><a class="header" href="#detailed-flow-1">Detailed Flow</a></h3>
<pre><code>┌──────────────────────────────────────────────────────────────────────┐
│                           USER CODE                                   │
│  let image = Image::from_layer(layer);                               │
│  image.write().to_file("output.exr")?;                               │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                        image/write/mod.rs                             │
│                                                                       │
│  WriteImageWithOptions::to_buffered(write)                           │
│    1. headers = self.infer_meta_data()                               │
│    2. layers = self.image.create_writer(&amp;headers)                    │
│    3. block::write(write, headers, checks, |meta, writer| { ... })   │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                         block/writer.rs                               │
│                                                                       │
│  block::write(write, headers, checks, callback)                      │
│    1. MetaData::write_validating_to_buffered() - magic + headers     │
│    2. Write placeholder offset table                                  │
│    3. Create ChunksWriter                                            │
│    4. Call user callback to write chunks                              │
│    5. Seek back and write final offset table                          │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                     ChunksWriter (block/writer.rs)                    │
│                                                                       │
│  compress_all_blocks_parallel()  - rayon thread pool                  │
│  compress_all_blocks_sequential() - single thread                     │
│                                                                       │
│  For each block:                                                      │
│    LayersWriter::extract_uncompressed_block()                        │
│    UncompressedBlock::compress_to_chunk()                            │
│    Write chunk to file                                                │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                      image/write/channels.rs                          │
│                                                                       │
│  ChannelsWriter::extract_uncompressed_block()                        │
│    - Iterates channels                                                │
│    - Calls user's get_pixel()                                        │
│    - Builds UncompressedBlock::from_lines()                          │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                          block/mod.rs                                 │
│                                                                       │
│  UncompressedBlock::compress_to_chunk(headers)                       │
│    1. Get header for this block's layer                               │
│    2. header.compression.compress_image_section_to_le()              │
│    3. Return Chunk { layer_index, compressed_block }                 │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                       compression/mod.rs                              │
│                                                                       │
│  Compression::compress_image_section_to_le()                         │
│                                                                       │
│  Pre-processing:                                                      │
│    native-endian → little-endian                                      │
│    separate_bytes_fragments() - reorder bytes                         │
│    samples_to_differences() - delta encoding                          │
│                                                                       │
│  match compression {                                                  │
│    Uncompressed =&gt; return LE bytes                                    │
│    RLE          =&gt; rle::compress()                                    │
│    ZIP/ZIPS     =&gt; zip::compress()                                    │
│    PIZ          =&gt; piz::compress()                                    │
│    PXR24        =&gt; pxr24::compress()                                  │
│    B44/B44A     =&gt; b44::compress()                                    │
│  }                                                                    │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                          ┌───────────────────┐
                          │   .exr File       │
                          │   (Written)       │
                          └───────────────────┘
</code></pre>
<h2 id="deep-data-pipeline"><a class="header" href="#deep-data-pipeline">Deep Data Pipeline</a></h2>
<h3 id="reading-deep"><a class="header" href="#reading-deep">Reading Deep</a></h3>
<pre><code>┌──────────────────────────────────────────────────────────────────────┐
│                       Deep Data Reading                               │
│                                                                       │
│  read_deep().all_channels().first_valid_layer().from_file()          │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                      image/read/deep.rs                               │
│                                                                       │
│  ReadDeepImage::from_buffered()                                      │
│    1. Reader::read_from_buffered()                                   │
│    2. Find deep layers (header.deep == true)                         │
│    3. read_deep_layer_internal()                                     │
│       a. reader.all_chunks()                                         │
│       b. decompress_blocks_parallel/sequential()                     │
│       c. Sort blocks by y-coordinate                                  │
│       d. merge_deep_blocks() - combine into DeepSamples              │
│    4. build_deep_layer()                                             │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                        block/deep.rs                                  │
│                                                                       │
│  decompress_deep_scanline_block()                                    │
│    1. Decompress sample count table (ZIP)                            │
│    2. Validate cumulative counts                                      │
│    3. Decompress sample data per compression                          │
│    4. Unpack channel data into DeepSamples                           │
└──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────┐
│                        image/deep.rs                                  │
│                                                                       │
│  DeepSamples {                                                       │
│    sample_offsets: Vec&lt;u32&gt;,    // Cumulative counts                 │
│    channels: Vec&lt;DeepChannelData&gt;,                                   │
│    width, height                                                      │
│  }                                                                    │
└──────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="block-merging"><a class="header" href="#block-merging">Block Merging</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│                     merge_deep_blocks()                              │
│                                                                      │
│  Input: Vec&lt;(y_offset, DeepSamples)&gt;  // Per-block samples          │
│                                                                      │
│  1. Build offset table                                               │
│     combined_offsets[total_pixels + 1] with leading 0               │
│                                                                      │
│  2. Collect counts                                                   │
│     Copy per-pixel counts to correct image positions                 │
│                                                                      │
│  3. Prefix sum                                                       │
│     Convert individual → cumulative offsets                          │
│                                                                      │
│  4. Allocate channels                                                │
│     Create output arrays sized to total_samples                      │
│                                                                      │
│  5. Copy data                                                        │
│     Place each block's samples at correct positions                  │
│                                                                      │
│  Output: DeepSamples for full image                                  │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="compression-flow"><a class="header" href="#compression-flow">Compression Flow</a></h2>
<h3 id="compression-pre-processing"><a class="header" href="#compression-pre-processing">Compression Pre-processing</a></h3>
<pre><code>Native Endian Bytes (from user)
         │
         ▼
┌─────────────────────────────────┐
│  Convert to Little Endian       │
│  (sample_to_le for each type)   │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  separate_bytes_fragments()     │
│  Reorder: [AABBCC] → [ABCABC]   │
│  (improves compression ratio)   │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  samples_to_differences()       │
│  Delta encoding: [1,3,6] →      │
│                  [1,2,3]        │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Compression Algorithm          │
│  (RLE/ZIP/PIZ/PXR24/B44)        │
└─────────────────────────────────┘
         │
         ▼
Compressed Bytes (to file)
</code></pre>
<h3 id="decompression-post-processing"><a class="header" href="#decompression-post-processing">Decompression Post-processing</a></h3>
<pre><code>Compressed Bytes (from file)
         │
         ▼
┌─────────────────────────────────┐
│  Decompression Algorithm        │
│  (reverse of above)             │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  differences_to_samples()       │
│  Undo delta: [1,2,3] →          │
│              [1,3,6]            │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  interleave_byte_blocks()       │
│  Reorder: [ABCABC] → [AABBCC]   │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Convert to Native Endian       │
│  (le_to_sample for each type)   │
└─────────────────────────────────┘
         │
         ▼
Native Endian Bytes (to user)
</code></pre>
<h2 id="parallel-processing-1"><a class="header" href="#parallel-processing-1">Parallel Processing</a></h2>
<h3 id="parallel-reading"><a class="header" href="#parallel-reading">Parallel Reading</a></h3>
<pre><code>File → Reader → Chunks
                  │
       ┌──────────┴──────────┐
       ▼                     ▼
  Decompress              Decompress
  (thread 1)              (thread 2)
       │                     │
       └──────────┬──────────┘
                  ▼
            mpsc::channel
                  │
                  ▼
            Assemble Image
            (main thread)
</code></pre>
<h3 id="parallel-writing"><a class="header" href="#parallel-writing">Parallel Writing</a></h3>
<pre><code>Image Data
     │
     ▼
Generate Blocks
     │
┌────┴────┐
▼         ▼
Compress  Compress    (rayon par_iter)
│         │
└────┬────┘
     ▼
mpsc::channel
     │
     ▼
Write to File
(main thread)
</code></pre>
<h2 id="file-format-layout"><a class="header" href="#file-format-layout">File Format Layout</a></h2>
<pre><code>OpenEXR File:
┌─────────────────────────────────────┐
│ Magic Number (4 bytes)              │  0x762f3101
├─────────────────────────────────────┤
│ Version + Flags (4 bytes)           │  Version 2 + feature bits
├─────────────────────────────────────┤
│ Header 1                            │
│   - Attributes (name=value pairs)   │
│   - 0x00 terminator                 │
├─────────────────────────────────────┤
│ [Header 2...N if multipart]         │
│   - 0x00 terminator after last      │
├─────────────────────────────────────┤
│ Offset Table 1                      │  Array of u64 chunk offsets
├─────────────────────────────────────┤
│ [Offset Table 2...N if multipart]   │
├─────────────────────────────────────┤
│ Chunk 1                             │
│   - Part number (if multipart)      │
│   - Coordinates (tile or scanline)  │
│   - Compressed pixel data           │
├─────────────────────────────────────┤
│ Chunk 2...M                         │
└─────────────────────────────────────┘
</code></pre>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See Also</a></h2>
<ul>
<li><a href="#architecture-overview">Architecture Overview</a> - High-level design</li>
<li><a href="#compression-algorithms">Compression Algorithms</a> - Algorithm details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="compression-algorithms"><a class="header" href="#compression-algorithms">Compression Algorithms</a></h1>
<p>exrs implements most OpenEXR compression methods. This document describes each algorithm.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Code</th><th>Lossless</th><th>Deep</th><th>Block Size</th></tr>
</thead>
<tbody>
<tr><td>Uncompressed</td><td>0</td><td>Yes</td><td>Yes</td><td>1 line</td></tr>
<tr><td>RLE</td><td>1</td><td>Yes</td><td>Yes</td><td>1 line</td></tr>
<tr><td>ZIPS</td><td>2</td><td>Yes</td><td>Yes</td><td>1 line</td></tr>
<tr><td>ZIP</td><td>3</td><td>Yes</td><td>Yes</td><td>16 lines</td></tr>
<tr><td>PIZ</td><td>4</td><td>Yes</td><td>No</td><td>32 lines</td></tr>
<tr><td>PXR24</td><td>5</td><td>No*</td><td>No</td><td>16 lines</td></tr>
<tr><td>B44</td><td>6</td><td>No</td><td>No</td><td>32 lines</td></tr>
<tr><td>B44A</td><td>7</td><td>No</td><td>No</td><td>32 lines</td></tr>
<tr><td>DWAA</td><td>8</td><td>No</td><td>No</td><td>32 lines</td></tr>
<tr><td>DWAB</td><td>9</td><td>No</td><td>No</td><td>256 lines</td></tr>
</tbody>
</table>
</div>
<p>*PXR24 is lossless for f16 and u32, lossy for f32.</p>
<h2 id="prepost-processing"><a class="header" href="#prepost-processing">Pre/Post Processing</a></h2>
<p>All compression methods share common pre/post processing:</p>
<h3 id="pre-processing-before-compression"><a class="header" href="#pre-processing-before-compression">Pre-processing (before compression)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Convert to little-endian
for sample in samples {
    sample.to_le_bytes();
}

// 2. Separate bytes for better compression
// [A1A2 B1B2 C1C2] → [A1B1C1 A2B2C2]
separate_bytes_fragments(&amp;mut bytes);

// 3. Delta encoding
// [10, 13, 16] → [10, 3, 3]
samples_to_differences(&amp;mut bytes);
<span class="boring">}</span></code></pre>
<h3 id="post-processing-after-decompression"><a class="header" href="#post-processing-after-decompression">Post-processing (after decompression)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Reverse order
differences_to_samples(&amp;mut bytes);  // [10, 3, 3] → [10, 13, 16]
interleave_byte_blocks(&amp;mut bytes);  // [A1B1C1 A2B2C2] → [A1A2 B1B2 C1C2]
to_native_endian(&amp;mut bytes);
<span class="boring">}</span></code></pre>
<h2 id="uncompressed"><a class="header" href="#uncompressed">Uncompressed</a></h2>
<p>Simply stores raw bytes in little-endian format.</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Fastest read/write</li>
<li>No CPU overhead</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Largest file size</li>
</ul>
<p><strong>Use when:</strong></p>
<ul>
<li>Maximum I/O speed needed</li>
<li>Debugging</li>
<li>SSD/NVMe storage</li>
</ul>
<h2 id="rle-run-length-encoding"><a class="header" href="#rle-run-length-encoding">RLE (Run-Length Encoding)</a></h2>
<p>Compresses runs of identical bytes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compress(uncompressed: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    // Count consecutive identical bytes
    // Encode as (count, value) pairs
    // Use negative count for literal runs
}
<span class="boring">}</span></code></pre>
<p><strong>Algorithm:</strong></p>
<ul>
<li>Positive count: repeat next byte N times</li>
<li>Negative count: copy next |N| bytes literally</li>
</ul>
<p><strong>Pros:</strong></p>
<ul>
<li>Fast compression/decompression</li>
<li>Good for simple patterns</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Poor for complex/noisy images</li>
</ul>
<p><strong>Use when:</strong></p>
<ul>
<li>Simple images (solid areas, gradients)</li>
<li>Speed more important than size</li>
</ul>
<h2 id="zip--zips"><a class="header" href="#zip--zips">ZIP / ZIPS</a></h2>
<p>Deflate compression using zlib format.</p>
<p><strong>ZIP:</strong> 16 scanlines per block
<strong>ZIPS:</strong> 1 scanline per block</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compression: miniz_oxide
pub fn compress(data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    miniz_oxide::deflate::compress_to_vec_zlib(data, 6)
}

// Decompression: zune-inflate (faster)
pub fn decompress(data: &amp;[u8], size: usize) -&gt; Vec&lt;u8&gt; {
    zune_inflate::DeflateDecoder::new(data)
        .decode_zlib()?
}
<span class="boring">}</span></code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Good compression ratio</li>
<li>Well-balanced speed</li>
<li>Universal compatibility</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Not the smallest files</li>
<li>Not the fastest</li>
</ul>
<p><strong>Use when:</strong></p>
<ul>
<li>General purpose (recommended default)</li>
<li>Good balance needed</li>
</ul>
<h2 id="piz"><a class="header" href="#piz">PIZ</a></h2>
<p>Wavelet-based compression with Huffman coding.</p>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<pre><code>Pixels → Wavelet Transform → Huffman Encode → Output
</code></pre>
<h3 id="wavelet-transform"><a class="header" href="#wavelet-transform">Wavelet Transform</a></h3>
<p>Haar wavelet on 16-bit values:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Horizontal pass
for row in rows {
    for i in (0..width).step_by(2) {
        let a = row[i];
        let b = row[i + 1];
        row[i] = (a + b) / 2;      // Average
        row[i + 1] = a - b;         // Difference
    }
}
// Vertical pass similarly
<span class="boring">}</span></code></pre>
<h3 id="huffman-coding"><a class="header" href="#huffman-coding">Huffman Coding</a></h3>
<p>Custom Huffman implementation for 16-bit symbols:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Build frequency table
// Generate canonical Huffman codes
// Encode symbols
<span class="boring">}</span></code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Excellent compression for noisy images</li>
<li>Better than ZIP for film grain, noise</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Slower than ZIP</li>
<li>32-line blocks (more memory)</li>
</ul>
<p><strong>Use when:</strong></p>
<ul>
<li>Film grain or noise present</li>
<li>Compression ratio critical</li>
<li>CPU time acceptable</li>
</ul>
<h2 id="pxr24"><a class="header" href="#pxr24">PXR24</a></h2>
<p>Pixar’s 24-bit float compression.</p>
<h3 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h3>
<ol>
<li>Convert f32 to 24-bit (truncate mantissa)</li>
<li>ZIP compress the result</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compress(data: &amp;[u8], channels: &amp;ChannelList) -&gt; Vec&lt;u8&gt; {
    for sample in samples {
        match channel.sample_type {
            F32 =&gt; {
                // Truncate to 24 bits (lose 8 bits precision)
                let bits = sample.to_bits();
                let truncated = bits &amp; 0xFFFFFF00;
            }
            F16 | U32 =&gt; {
                // Keep full precision
            }
        }
    }
    zip::compress(&amp;truncated)
}
<span class="boring">}</span></code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>Good compression for f32 images</li>
<li>Fast (just ZIP + truncation)</li>
<li>Lossless for f16 and u32</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Lossy for f32 (8 bits precision lost)</li>
<li>Not great for f16 images</li>
</ul>
<p><strong>Use when:</strong></p>
<ul>
<li>Large f32 images</li>
<li>Slight quality loss acceptable</li>
<li>Good speed needed</li>
</ul>
<h2 id="b44--b44a"><a class="header" href="#b44--b44a">B44 / B44A</a></h2>
<p>Block-based compression for 16-bit floats.</p>
<h3 id="algorithm-1"><a class="header" href="#algorithm-1">Algorithm</a></h3>
<p>Divides image into 4x4 blocks, compresses each to fixed size:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Each 4x4 block (32 bytes) → 14 bytes
// Uses lookup tables for fast encoding/decoding
<span class="boring">}</span></code></pre>
<p><strong>B44:</strong> All blocks compressed
<strong>B44A:</strong> Flat (constant) blocks stored as single value</p>
<h3 id="lookup-tables"><a class="header" href="#lookup-tables">Lookup Tables</a></h3>
<p>The <code>table.rs</code> file contains 10,928 lines of precomputed values for fast encoding.</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Fixed compression ratio (predictable)</li>
<li>Fast decompression (good for playback)</li>
<li>B44A handles flat areas well</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Lossy compression</li>
<li>Only works with f16</li>
<li>Visible artifacts on gradients</li>
</ul>
<p><strong>Use when:</strong></p>
<ul>
<li>Real-time playback needed</li>
<li>Texture compression</li>
<li>Fixed bitrate required</li>
</ul>
<h2 id="dwaa--dwab-not-implemented"><a class="header" href="#dwaa--dwab-not-implemented">DWAA / DWAB (Not Implemented)</a></h2>
<p>DCT-based lossy compression.</p>
<p><strong>DWAA:</strong> 32 scanlines per block
<strong>DWAB:</strong> 256 scanlines per block</p>
<p><strong>Status:</strong> Not yet implemented in exrs.</p>
<h2 id="deep-data-compression-1"><a class="header" href="#deep-data-compression-1">Deep Data Compression</a></h2>
<p>Deep data uses modified compression:</p>
<h3 id="sample-table"><a class="header" href="#sample-table">Sample Table</a></h3>
<p>Cumulative sample counts per pixel:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compress_sample_table(
    compression: Compression,
    counts: &amp;[i32]
) -&gt; Vec&lt;u8&gt; {
    match compression {
        Uncompressed =&gt; counts.to_bytes(),
        RLE =&gt; rle::compress(&amp;counts.to_bytes()),
        ZIP | ZIPS =&gt; zip::compress(&amp;counts.to_bytes()),
        _ =&gt; unsupported!()
    }
}
<span class="boring">}</span></code></pre>
<h3 id="sample-data"><a class="header" href="#sample-data">Sample Data</a></h3>
<p>Per-channel data compressed separately:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compress_sample_data(
    compression: Compression,
    channels: &amp;[DeepChannelData]
) -&gt; Vec&lt;u8&gt; {
    // Interleave by pixel
    // Apply standard compression
}
<span class="boring">}</span></code></pre>
<h3 id="supported-for-deep"><a class="header" href="#supported-for-deep">Supported for Deep</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Sample Table</th><th>Sample Data</th></tr>
</thead>
<tbody>
<tr><td>Uncompressed</td><td>Yes</td><td>Yes</td></tr>
<tr><td>RLE</td><td>Yes</td><td>Yes</td></tr>
<tr><td>ZIPS</td><td>Yes</td><td>Yes</td></tr>
<tr><td>ZIP</td><td>Yes</td><td>Yes</td></tr>
<tr><td>PIZ</td><td>No</td><td>No</td></tr>
<tr><td>PXR24</td><td>No</td><td>No</td></tr>
<tr><td>B44/B44A</td><td>No</td><td>No</td></tr>
</tbody>
</table>
</div>
<h2 id="choosing-compression-1"><a class="header" href="#choosing-compression-1">Choosing Compression</a></h2>
<h3 id="decision-tree"><a class="header" href="#decision-tree">Decision Tree</a></h3>
<pre><code>Is speed critical?
├── Yes → Uncompressed
└── No
    │
    Is it deep data?
    ├── Yes → ZIP (ZIPS for streaming)
    └── No
        │
        Is the image noisy/grainy?
        ├── Yes → PIZ
        └── No
            │
            Is it mostly f32?
            ├── Yes → PXR24 (if loss OK) or ZIP
            └── No
                │
                Need fixed bitrate?
                ├── Yes → B44/B44A
                └── No → ZIP (default)
</code></pre>
<h3 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>General purpose</td><td>ZIP</td></tr>
<tr><td>Maximum speed</td><td>Uncompressed</td></tr>
<tr><td>Film/VFX (noisy)</td><td>PIZ</td></tr>
<tr><td>Real-time playback</td><td>B44/B44A</td></tr>
<tr><td>Deep data</td><td>ZIP</td></tr>
<tr><td>Maximum compression</td><td>PIZ</td></tr>
<tr><td>Large f32 images</td><td>PXR24</td></tr>
</tbody>
</table>
</div>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<p>Each compression method has different memory characteristics:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Temp Memory</th><th>Block Size</th></tr>
</thead>
<tbody>
<tr><td>Uncompressed</td><td>None</td><td>1 line</td></tr>
<tr><td>RLE</td><td>2x block</td><td>1 line</td></tr>
<tr><td>ZIP</td><td>~1MB</td><td>16 lines</td></tr>
<tr><td>PIZ</td><td>2x block + tables</td><td>32 lines</td></tr>
<tr><td>PXR24</td><td>2x block</td><td>16 lines</td></tr>
<tr><td>B44</td><td>Tables (~40KB)</td><td>32 lines</td></tr>
</tbody>
</table>
</div>
<h3 id="thread-safety-1"><a class="header" href="#thread-safety-1">Thread Safety</a></h3>
<p>All compression functions are stateless and thread-safe. The library uses rayon for parallel compression/decompression.</p>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See Also</a></h2>
<ul>
<li><a href="#data-flow-1">Data Flow</a> - How compression fits in the pipeline</li>
<li><a href="#architecture-overview">Architecture</a> - Overall library design</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h1>
<p>Welcome! This guide helps you contribute to exrs.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<h3 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone the Repository</a></h3>
<pre><code class="language-bash">git clone https://github.com/johannesvollmer/exrs.git
cd exrs
</code></pre>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<pre><code class="language-bash">cargo build
</code></pre>
<h3 id="run-tests"><a class="header" href="#run-tests">Run Tests</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="run-benchmarks"><a class="header" href="#run-benchmarks">Run Benchmarks</a></h3>
<pre><code class="language-bash">cargo bench
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<pre><code>exrs/
├── src/                    # Library source
│   ├── lib.rs             # Crate root
│   ├── block/             # Low-level block I/O
│   ├── compression/       # Compression algorithms
│   ├── image/             # High-level API
│   ├── meta/              # Metadata types
│   └── ...
├── examples/              # Usage examples
├── tests/                 # Integration tests
│   ├── images/            # Test images
│   │   ├── valid/         # Valid EXR files
│   │   └── invalid/       # Invalid/fuzzed files
│   └── *.rs               # Test files
├── benches/               # Benchmarks
├── docs/                  # This documentation
└── specification/         # OpenEXR specs (PDFs)
</code></pre>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<h3 id="1-create-a-branch"><a class="header" href="#1-create-a-branch">1. Create a Branch</a></h3>
<pre><code class="language-bash">git checkout -b feature/my-feature
</code></pre>
<h3 id="2-make-changes"><a class="header" href="#2-make-changes">2. Make Changes</a></h3>
<p>Follow the code style guidelines below.</p>
<h3 id="3-run-tests"><a class="header" href="#3-run-tests">3. Run Tests</a></h3>
<pre><code class="language-bash"># All tests
cargo test

# Specific test
cargo test test_name

# With output
cargo test -- --nocapture
</code></pre>
<h3 id="4-run-clippy"><a class="header" href="#4-run-clippy">4. Run Clippy</a></h3>
<pre><code class="language-bash">cargo clippy --all-targets --all-features
</code></pre>
<h3 id="5-format-code"><a class="header" href="#5-format-code">5. Format Code</a></h3>
<pre><code class="language-bash">cargo fmt
</code></pre>
<h3 id="6-submit-pr"><a class="header" href="#6-submit-pr">6. Submit PR</a></h3>
<p>Push your branch and create a pull request.</p>
<h2 id="code-style"><a class="header" href="#code-style">Code Style</a></h2>
<h3 id="rust-conventions"><a class="header" href="#rust-conventions">Rust Conventions</a></h3>
<ul>
<li>Follow Rust naming conventions</li>
<li>Use <code>rustfmt</code> for formatting</li>
<li>Address all <code>clippy</code> warnings</li>
</ul>
<h3 id="documentation-1"><a class="header" href="#documentation-1">Documentation</a></h3>
<ul>
<li>Document public items with <code>///</code></li>
<li>Include examples in doc comments</li>
<li>Use <code>#[doc(hidden)]</code> sparingly</li>
</ul>
<h3 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use the crate's Result type
use crate::error::{Error, Result};

// Return descriptive errors
fn parse_data(bytes: &amp;[u8]) -&gt; Result&lt;Data&gt; {
    if bytes.len() &lt; 4 {
        return Err(Error::Invalid("data too short".into()));
    }
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="safety"><a class="header" href="#safety">Safety</a></h3>
<ul>
<li>No <code>unsafe</code> code (library uses <code>#[forbid(unsafe_code)]</code>)</li>
<li>Validate all external input</li>
<li>Use bounds-checked operations</li>
</ul>
<h2 id="adding-features"><a class="header" href="#adding-features">Adding Features</a></h2>
<h3 id="new-compression-method"><a class="header" href="#new-compression-method">New Compression Method</a></h3>
<ol>
<li>Create <code>src/compression/method.rs</code></li>
<li>Add variant to <code>Compression</code> enum</li>
<li>Add dispatch in <code>compression/mod.rs</code></li>
<li>Add tests</li>
<li>Update documentation</li>
</ol>
<h3 id="new-attribute-type"><a class="header" href="#new-attribute-type">New Attribute Type</a></h3>
<ol>
<li>Add variant to <code>AttributeValue</code> enum in <code>meta/attribute.rs</code></li>
<li>Implement <code>Data</code> trait (read/write)</li>
<li>Add tests</li>
<li>Update documentation</li>
</ol>
<h3 id="new-readerwriter-option"><a class="header" href="#new-readerwriter-option">New Reader/Writer Option</a></h3>
<ol>
<li>Add builder method in appropriate module</li>
<li>Add type state if needed</li>
<li>Update integration tests</li>
<li>Add example if user-facing</li>
</ol>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="unit-tests-1"><a class="header" href="#unit-tests-1">Unit Tests</a></h3>
<p>Place in the same file:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_something() {
        // ...
    }
}
<span class="boring">}</span></code></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>Place in <code>tests/</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/my_feature.rs
use exr::prelude::*;

#[test]
fn test_feature() {
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="test-images-1"><a class="header" href="#test-images-1">Test Images</a></h3>
<ul>
<li><code>tests/images/valid/</code> - Valid EXR files</li>
<li><code>tests/images/invalid/</code> - Invalid/edge case files</li>
</ul>
<h3 id="fuzz-testing"><a class="header" href="#fuzz-testing">Fuzz Testing</a></h3>
<pre><code class="language-bash"># Run indefinitely
cargo test --package exr --test fuzz fuzz -- --exact --ignored
</code></pre>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>Located in <code>benches/</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// benches/read.rs
use bencher::{benchmark_group, benchmark_main, Bencher};

fn bench_read(b: &amp;mut Bencher) {
    b.iter(|| {
        // ...
    });
}

benchmark_group!(benches, bench_read);
benchmark_main!(benches);
<span class="boring">}</span></code></pre>
<p>Run:</p>
<pre><code class="language-bash">cargo bench
</code></pre>
<h2 id="pull-request-guidelines"><a class="header" href="#pull-request-guidelines">Pull Request Guidelines</a></h2>
<h3 id="title"><a class="header" href="#title">Title</a></h3>
<p>Use conventional commit format:</p>
<ul>
<li><code>feat: Add DWAA compression</code></li>
<li><code>fix: Handle empty deep pixels</code></li>
<li><code>docs: Update GUIDE.md</code></li>
<li><code>refactor: Simplify block reader</code></li>
<li><code>test: Add roundtrip tests for deep</code></li>
</ul>
<h3 id="description"><a class="header" href="#description">Description</a></h3>
<p>Include:</p>
<ol>
<li>What the PR does</li>
<li>Why it’s needed</li>
<li>How to test</li>
<li>Breaking changes (if any)</li>
</ol>
<h3 id="checklist"><a class="header" href="#checklist">Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Tests pass</li>
<li><input disabled="" type="checkbox"> Clippy passes</li>
<li><input disabled="" type="checkbox"> Code formatted</li>
<li><input disabled="" type="checkbox"> Documentation updated</li>
<li><input disabled="" type="checkbox"> Examples updated (if needed)</li>
</ul>
<h2 id="common-tasks"><a class="header" href="#common-tasks">Common Tasks</a></h2>
<h3 id="adding-a-test-image"><a class="header" href="#adding-a-test-image">Adding a Test Image</a></h3>
<ol>
<li>Place in <code>tests/images/valid/</code> or <code>tests/images/invalid/</code></li>
<li>Update <code>.gitignore</code> if large</li>
<li>Reference in tests</li>
</ol>
<h3 id="updating-dependencies"><a class="header" href="#updating-dependencies">Updating Dependencies</a></h3>
<pre><code class="language-bash">cargo update
cargo test
</code></pre>
<h3 id="generating-docs"><a class="header" href="#generating-docs">Generating Docs</a></h3>
<pre><code class="language-bash">cargo doc --open
</code></pre>
<h3 id="building-for-wasm"><a class="header" href="#building-for-wasm">Building for WASM</a></h3>
<pre><code class="language-bash">cargo build --target wasm32-unknown-unknown --no-default-features
</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li>Open an issue for questions</li>
<li>Check existing issues/PRs</li>
<li>Read the specification PDFs in <code>specification/</code></li>
</ul>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>Be respectful and constructive. We welcome contributors of all experience levels.</p>
<h2 id="license-1"><a class="header" href="#license-1">License</a></h2>
<p>Contributions are licensed under BSD-3-Clause, matching the project license.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-1"><a class="header" href="#testing-1">Testing</a></h1>
<p>Comprehensive guide to testing exrs.</p>
<h2 id="test-categories"><a class="header" href="#test-categories">Test Categories</a></h2>
<h3 id="unit-tests-2"><a class="header" href="#unit-tests-2">Unit Tests</a></h3>
<p>Located within source files:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_compression() {
        let data = vec![1, 2, 3, 4];
        let compressed = compress(&amp;data).unwrap();
        let decompressed = decompress(&amp;compressed, data.len()).unwrap();
        assert_eq!(data, decompressed);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration Tests</a></h3>
<p>Located in <code>tests/</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>roundtrip.rs</code></td><td>Write then read, verify equality</td></tr>
<tr><td><code>across_compression.rs</code></td><td>Test all compression methods</td></tr>
<tr><td><code>deep_read.rs</code></td><td>Deep data reading</td></tr>
<tr><td><code>deep_benchmark.rs</code></td><td>Deep performance</td></tr>
<tr><td><code>fuzz.rs</code></td><td>Fuzz testing</td></tr>
<tr><td><code>dev.rs</code></td><td>Development tests</td></tr>
</tbody>
</table>
</div>
<h3 id="fuzz-tests"><a class="header" href="#fuzz-tests">Fuzz Tests</a></h3>
<p>Randomized testing for robustness:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore]  // Run explicitly
fn fuzz() {
    loop {
        let random_image = generate_random_image();
        write_and_read_back(random_image);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<h3 id="all-tests"><a class="header" href="#all-tests">All Tests</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="specific-test"><a class="header" href="#specific-test">Specific Test</a></h3>
<pre><code class="language-bash">cargo test test_name
</code></pre>
<h3 id="with-output"><a class="header" href="#with-output">With Output</a></h3>
<pre><code class="language-bash">cargo test -- --nocapture
</code></pre>
<h3 id="release-mode"><a class="header" href="#release-mode">Release Mode</a></h3>
<pre><code class="language-bash">cargo test --release
</code></pre>
<h3 id="ignored-tests"><a class="header" href="#ignored-tests">Ignored Tests</a></h3>
<pre><code class="language-bash">cargo test -- --ignored
</code></pre>
<h3 id="fuzz-testing-1"><a class="header" href="#fuzz-testing-1">Fuzz Testing</a></h3>
<pre><code class="language-bash"># Run indefinitely
cargo test --package exr --test fuzz fuzz -- --exact --ignored
</code></pre>
<h2 id="test-images-2"><a class="header" href="#test-images-2">Test Images</a></h2>
<h3 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h3>
<pre><code>tests/images/
├── valid/
│   ├── custom/              # Custom test images
│   │   ├── compression_methods/
│   │   └── crowskull/
│   └── openexr/             # Official test images
│       ├── Beachball/
│       ├── Chromaticities/
│       ├── DisplayWindow/
│       ├── IlmfmlmflmTest/
│       ├── LuminanceChroma/
│       ├── MultiResolution/
│       ├── MultiView/
│       ├── ScanLines/
│       ├── TestImages/
│       ├── Tiles/
│       └── v2/              # Deep data images
│           ├── deep_large/
│           ├── LeftView/
│           ├── LowResLeftView/
│           └── Stereo/
└── invalid/
    ├── fuzzed/              # Fuzz-discovered crashes
    └── openexr/
        ├── Damaged/         # Intentionally corrupt
        └── IlmlfmlflmTest/  # Edge cases
</code></pre>
<h3 id="deep-test-images"><a class="header" href="#deep-test-images">Deep Test Images</a></h3>
<p>Official OpenEXR deep test files:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Size</th><th>Samples</th><th>Use</th></tr>
</thead>
<tbody>
<tr><td>MiniCooper720p.exr</td><td>~5MB</td><td>932K</td><td>Benchmark</td></tr>
<tr><td>PiranhnaAlienRun720p.exr</td><td>~4MB</td><td>~500K</td><td>Particles</td></tr>
<tr><td>Teaset720p.exr</td><td>~6MB</td><td>997K</td><td>Complex scene</td></tr>
<tr><td>Balls.exr</td><td>~1MB</td><td>94K</td><td>Simple shapes</td></tr>
<tr><td>Ground.exr</td><td>~2MB</td><td>360K</td><td>Ground plane</td></tr>
</tbody>
</table>
</div>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<h3 id="basic-test"><a class="header" href="#basic-test">Basic Test</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_read_write() {
    use exr::prelude::*;
    
    // Create test image
    let image = Image::from_channels(
        (100, 100),
        SpecificChannels::rgba(|pos| {
            (pos.x() as f32 / 100.0, 0.0, 0.0, 1.0)
        })
    );
    
    // Write
    let mut bytes = Vec::new();
    image.write().to_buffered(Cursor::new(&amp;mut bytes)).unwrap();
    
    // Read back
    let loaded = read_all_data_from_file(...).unwrap();
    
    // Verify
    assert_eq!(image.layer_data.size, loaded.layer_data[0].size);
}
<span class="boring">}</span></code></pre>
<h3 id="roundtrip-test"><a class="header" href="#roundtrip-test">Roundtrip Test</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn roundtrip_compression() {
    for compression in [
        Compression::Uncompressed,
        Compression::RLE,
        Compression::ZIPS,
        Compression::ZIP,
        Compression::PIZ,
        Compression::PXR24,
        Compression::B44,
    ] {
        let layer = Layer::new(
            (256, 256),
            LayerAttributes::named("test"),
            Encoding {
                compression,
                ..Default::default()
            },
            generate_test_channels()
        );
        
        let image = Image::from_layer(layer);
        
        // Write and read
        let mut buffer = Vec::new();
        image.write().to_buffered(Cursor::new(&amp;mut buffer)).unwrap();
        
        let loaded = read_all_data_from_file(Cursor::new(&amp;buffer)).unwrap();
        
        // Verify (accounting for lossy compression)
        verify_similar(&amp;image, &amp;loaded, compression.is_lossless());
    }
}
<span class="boring">}</span></code></pre>
<h3 id="deep-data-test"><a class="header" href="#deep-data-test">Deep Data Test</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_deep_read() {
    use exr::image::read::deep::read_first_deep_layer_from_file;
    
    let image = read_first_deep_layer_from_file(
        "tests/images/valid/openexr/v2/LowResLeftView/Balls.exr"
    ).expect("failed to read deep image");
    
    let samples = &amp;image.layer_data.channel_data.list[0].sample_data;
    
    // Verify structure
    assert!(samples.total_samples() &gt; 0);
    assert!(samples.width &gt; 0);
    assert!(samples.height &gt; 0);
    
    // Verify data integrity
    for y in 0..samples.height {
        for x in 0..samples.width {
            let count = samples.sample_count(x, y);
            let (start, end) = samples.sample_range(y * samples.width + x);
            assert_eq!(end - start, count);
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="benchmark-test"><a class="header" href="#benchmark-test">Benchmark Test</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn benchmark_deep_read() {
    use std::time::Instant;
    
    let files = [
        "tests/images/valid/openexr/v2/deep_large/Teaset720p.exr",
    ];
    
    for path in files {
        // Parallel
        let start = Instant::now();
        let _ = read_first_deep_layer_from_file(path);
        let parallel = start.elapsed();
        
        // Sequential
        let start = Instant::now();
        let _ = read_deep()
            .all_channels()
            .first_valid_layer()
            .all_attributes()
            .non_parallel()
            .from_file(path);
        let sequential = start.elapsed();
        
        println!("{}: parallel={:?}, sequential={:?}, speedup={:.2}x",
            path, parallel, sequential,
            sequential.as_secs_f64() / parallel.as_secs_f64()
        );
    }
}
<span class="boring">}</span></code></pre>
<h2 id="test-utilities"><a class="header" href="#test-utilities">Test Utilities</a></h2>
<h3 id="validate-results-module"><a class="header" href="#validate-results-module">Validate Results Module</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(any(test, feature = "test-utils"))]
pub mod validate_results {
    pub fn compare_images(a: &amp;Image, b: &amp;Image, tolerance: f32) -&gt; bool;
    pub fn verify_deep_structure(samples: &amp;DeepSamples) -&gt; bool;
}
<span class="boring">}</span></code></pre>
<h3 id="test-helpers"><a class="header" href="#test-helpers">Test Helpers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_test_image(width: usize, height: usize) -&gt; Image&lt;...&gt; {
    Image::from_channels(
        (width, height),
        SpecificChannels::rgba(|pos| {
            let x = pos.x() as f32 / width as f32;
            let y = pos.y() as f32 / height as f32;
            (x, y, (x + y) / 2.0, 1.0)
        })
    )
}

fn temp_file() -&gt; PathBuf {
    let mut path = std::env::temp_dir();
    path.push(format!("exr_test_{}.exr", rand::random::&lt;u64&gt;()));
    path
}
<span class="boring">}</span></code></pre>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<pre><code class="language-yaml"># .github/workflows/rust.yml
name: Rust

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
    - name: Clippy
      run: cargo clippy --all-targets
</code></pre>
<h3 id="cross-platform-testing"><a class="header" href="#cross-platform-testing">Cross-Platform Testing</a></h3>
<pre><code class="language-bash"># PowerPC (big-endian)
cross test --target powerpc-unknown-linux-gnu --verbose
</code></pre>
<h2 id="coverage"><a class="header" href="#coverage">Coverage</a></h2>
<h3 id="generate-coverage"><a class="header" href="#generate-coverage">Generate Coverage</a></h3>
<pre><code class="language-bash">cargo install cargo-tarpaulin
cargo tarpaulin --out Html
</code></pre>
<h3 id="view-report"><a class="header" href="#view-report">View Report</a></h3>
<p>Open <code>tarpaulin-report.html</code> in browser.</p>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="benchmarks-1"><a class="header" href="#benchmarks-1">Benchmarks</a></h3>
<pre><code class="language-bash">cargo bench
</code></pre>
<h3 id="profiling"><a class="header" href="#profiling">Profiling</a></h3>
<pre><code class="language-bash">cargo build --release
# Use your preferred profiler (perf, Instruments, etc.)
</code></pre>
<h3 id="memory-usage-1"><a class="header" href="#memory-usage-1">Memory Usage</a></h3>
<pre><code class="language-bash">cargo build --release
valgrind --tool=massif ./target/release/example
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="test-fails-with-missing-file"><a class="header" href="#test-fails-with-missing-file">Test Fails with Missing File</a></h3>
<p>Ensure test images are downloaded:</p>
<pre><code class="language-bash">git lfs pull
</code></pre>
<h3 id="test-hangs"><a class="header" href="#test-hangs">Test Hangs</a></h3>
<p>Fuzz test runs forever by design. Use Ctrl+C to stop.</p>
<h3 id="memory-issues"><a class="header" href="#memory-issues">Memory Issues</a></h3>
<p>Some tests create large images. Use <code>--test-threads=1</code>:</p>
<pre><code class="language-bash">cargo test -- --test-threads=1
</code></pre>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See Also</a></h2>
<ul>
<li><a href="#contributing-1">Contributing</a> - How to contribute</li>
<li><a href="#architecture-overview">Architecture</a> - Code structure</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="prelude"><a class="header" href="#prelude">Prelude</a></h1>
<p>The <code>exr::prelude</code> module re-exports the most commonly used types and functions.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::prelude::*;
<span class="boring">}</span></code></pre>
<h2 id="exported-items"><a class="header" href="#exported-items">Exported Items</a></h2>
<h3 id="convenience-functions-2"><a class="header" href="#convenience-functions-2">Convenience Functions</a></h3>
<h4 id="reading"><a class="header" href="#reading">Reading</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Read first RGBA layer with custom storage
pub fn read_first_rgba_layer_from_file&lt;P, C, S, Px&gt;(
    path: impl AsRef&lt;Path&gt;,
    constructor: C,
    setter: S,
) -&gt; Result&lt;Image&lt;Layer&lt;SpecificChannels&lt;P, RgbaChannels&gt;&gt;&gt;&gt;
where
    C: FnOnce(Vec2&lt;usize&gt;, &amp;RgbaChannels) -&gt; P,
    S: FnMut(&amp;mut P, Vec2&lt;usize&gt;, Px);

/// Read all RGBA layers
pub fn read_all_rgba_layers_from_file&lt;...&gt;(...) -&gt; Result&lt;Image&lt;Layers&lt;...&gt;&gt;&gt;;

/// Read first flat layer (any channels)
pub fn read_first_flat_layer_from_file(
    path: impl AsRef&lt;Path&gt;
) -&gt; Result&lt;Image&lt;Layer&lt;AnyChannels&lt;FlatSamples&gt;&gt;&gt;&gt;;

/// Read all flat layers
pub fn read_all_flat_layers_from_file(
    path: impl AsRef&lt;Path&gt;
) -&gt; Result&lt;Image&lt;Layers&lt;AnyChannels&lt;FlatSamples&gt;&gt;&gt;&gt;;

/// Read everything (most flexible)
pub fn read_all_data_from_file(
    path: impl AsRef&lt;Path&gt;
) -&gt; Result&lt;Image&lt;Layers&lt;AnyChannels&lt;FlatSamples&gt;&gt;&gt;&gt;;

/// Read first layer (deep or flat)
pub fn read_first_any_layer_from_file(
    path: impl AsRef&lt;Path&gt;
) -&gt; Result&lt;Image&lt;Layer&lt;AnyChannels&lt;DeepAndFlatSamples&gt;&gt;&gt;&gt;;
<span class="boring">}</span></code></pre>
<h4 id="writing"><a class="header" href="#writing">Writing</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Write RGBA image
pub fn write_rgba_file&lt;P&gt;(
    path: impl AsRef&lt;Path&gt;,
    width: usize,
    height: usize,
    pixels: impl Fn(usize, usize) -&gt; P,
) -&gt; UnitResult
where P: Into&lt;(impl Into&lt;Sample&gt;, impl Into&lt;Sample&gt;, impl Into&lt;Sample&gt;, impl Into&lt;Sample&gt;)&gt;;

/// Write RGB image
pub fn write_rgb_file&lt;P&gt;(
    path: impl AsRef&lt;Path&gt;,
    width: usize,
    height: usize,
    pixels: impl Fn(usize, usize) -&gt; P,
) -&gt; UnitResult
where P: Into&lt;(impl Into&lt;Sample&gt;, impl Into&lt;Sample&gt;, impl Into&lt;Sample&gt;)&gt;;
<span class="boring">}</span></code></pre>
<h3 id="builder-entry-point"><a class="header" href="#builder-entry-point">Builder Entry Point</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Start building a read operation
pub fn read() -&gt; ReadBuilder;
<span class="boring">}</span></code></pre>
<h3 id="image-types"><a class="header" href="#image-types">Image Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Top-level image container
pub struct Image&lt;Layers&gt; {
    pub attributes: ImageAttributes,
    pub layer_data: Layers,
}

/// Single layer
pub struct Layer&lt;Channels&gt; {
    pub channel_data: Channels,
    pub attributes: LayerAttributes,
    pub size: Vec2&lt;usize&gt;,
    pub encoding: Encoding,
}

/// How pixels are stored in file
pub struct Encoding {
    pub compression: Compression,
    pub blocks: Blocks,
    pub line_order: LineOrder,
}
<span class="boring">}</span></code></pre>
<h3 id="channel-types-1"><a class="header" href="#channel-types-1">Channel Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Dynamic channel list
pub struct AnyChannels&lt;Samples&gt; {
    pub list: SmallVec&lt;[AnyChannel&lt;Samples&gt;; 4]&gt;,
}

/// Single channel
pub struct AnyChannel&lt;Samples&gt; {
    pub name: Text,
    pub sample_data: Samples,
    pub quantize_linearly: bool,
    pub sampling: Vec2&lt;usize&gt;,
}

/// Static channel set
pub struct SpecificChannels&lt;Pixels, ChannelDescriptions&gt; {
    pub channels: ChannelDescriptions,
    pub pixels: Pixels,
}
<span class="boring">}</span></code></pre>
<h3 id="sample-types-1"><a class="header" href="#sample-types-1">Sample Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Flat samples (one per pixel)
pub enum FlatSamples {
    F16(Vec&lt;f16&gt;),
    F32(Vec&lt;f32&gt;),
    U32(Vec&lt;u32&gt;),
}

/// Dynamic sample type
pub enum Sample {
    F16(f16),
    F32(f32),
    U32(u32),
}
<span class="boring">}</span></code></pre>
<h3 id="metadata-types"><a class="header" href="#metadata-types">Metadata Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Image-level attributes
pub struct ImageAttributes {
    pub display_window: IntegerBounds,
    pub pixel_aspect: f32,
    pub chromaticities: Option&lt;Chromaticities&gt;,
    pub time_code: Option&lt;TimeCode&gt;,
    pub other: HashMap&lt;Text, AttributeValue&gt;,
}

/// Layer-level attributes
pub struct LayerAttributes {
    pub layer_name: Option&lt;Text&gt;,
    pub owner: Option&lt;Text&gt;,
    pub comments: Option&lt;Text&gt;,
    pub software_name: Option&lt;Text&gt;,
    // ... many more
    pub other: HashMap&lt;Text, AttributeValue&gt;,
}

/// Channel description
pub struct ChannelDescription {
    pub name: Text,
    pub sample_type: SampleType,
    pub quantize_linearly: bool,
    pub sampling: Vec2&lt;usize&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="compression-1"><a class="header" href="#compression-1">Compression</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Compression {
    Uncompressed,
    RLE,
    ZIPS,
    ZIP,
    PIZ,
    PXR24,
    B44,
    B44A,
    DWAA,  // Not yet implemented
    DWAB,  // Not yet implemented
}
<span class="boring">}</span></code></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum LineOrder {
    Increasing,
    Decreasing,
    Unspecified,
}

pub enum SampleType {
    U32,
    F16,
    F32,
}

pub enum Blocks {
    ScanLines,
    Tiles(TileDescription),
}
<span class="boring">}</span></code></pre>
<h3 id="math-types"><a class="header" href="#math-types">Math Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 2D vector
pub struct Vec2&lt;T&gt;(pub T, pub T);

impl&lt;T&gt; Vec2&lt;T&gt; {
    pub fn x(&amp;self) -&gt; T;
    pub fn y(&amp;self) -&gt; T;
    pub fn width(&amp;self) -&gt; T;   // Alias
    pub fn height(&amp;self) -&gt; T;  // Alias
}

/// Integer rectangle
pub struct IntegerBounds {
    pub position: Vec2&lt;i32&gt;,
    pub size: Vec2&lt;usize&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Error {
    NotSupported(Cow&lt;'static, str&gt;),
    Invalid(Cow&lt;'static, str&gt;),
    Io(std::io::Error),
    Aborted,
}

pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;
pub type UnitResult = Result&lt;()&gt;;
<span class="boring">}</span></code></pre>
<h3 id="re-exports"><a class="header" href="#re-exports">Re-exports</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use half::f16;
pub use smallvec::SmallVec;
<span class="boring">}</span></code></pre>
<h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Reading traits
pub use crate::image::read::{
    ReadImage,
    ReadLayers,
    ReadChannels,
    ReadSamples,
    ReadSpecificChannel,
};

/// Writing traits
pub use crate::image::write::{
    WritableImage,
    GetPixel,
};

/// Cropping traits
pub use crate::image::crop::{
    Crop,
    CropResult,
    CropWhere,
    ApplyCroppedView,
    CroppedChannels,
    InspectSample,
};
<span class="boring">}</span></code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre class="playground"><code class="language-rust">use exr::prelude::*;

fn main() -&gt; Result&lt;()&gt; {
    // Write
    write_rgba_file("test.exr", 100, 100, |x, y| {
        (x as f32 / 100.0, y as f32 / 100.0, 0.5_f32, 1.0_f32)
    })?;
    
    // Read
    let image = read_all_data_from_file("test.exr")?;
    
    println!("Layers: {}", image.layer_data.len());
    for layer in &amp;image.layer_data {
        println!("  Size: {:?}", layer.size);
        println!("  Channels: {}", layer.channel_data.list.len());
    }
    
    Ok(())
}</code></pre>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See Also</a></h2>
<ul>
<li><a href="#image-module">Image Module</a> - Full image API</li>
<li><a href="#meta-module">Meta Module</a> - Metadata types</li>
<li><a href="#quick-start">User Guide: Quick Start</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="image-module"><a class="header" href="#image-module">Image Module</a></h1>
<p>The <code>exr::image</code> module provides high-level APIs for reading and writing EXR images.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="image"><a class="header" href="#image">Image</a></h3>
<p>Top-level container for EXR data:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Image&lt;Layers&gt; {
    /// Image-level attributes (display window, etc.)
    pub attributes: ImageAttributes,
    
    /// Layer data (single layer or multiple)
    pub layer_data: Layers,
}

impl&lt;L&gt; Image&lt;L&gt; {
    /// Create from layer data
    pub fn new(attributes: ImageAttributes, layer_data: L) -&gt; Self;
    
    /// Create with default attributes
    pub fn from_layer(layer: L) -&gt; Self;
    
    /// Create with channels directly
    pub fn from_channels(size: impl Into&lt;Vec2&lt;usize&gt;&gt;, channels: C) -&gt; Self;
    
    /// Create empty, add layers with .with_layer()
    pub fn empty(attributes: ImageAttributes) -&gt; Self;
    
    /// Add a layer (returns new Image with different type)
    pub fn with_layer&lt;N&gt;(self, layer: Layer&lt;N&gt;) -&gt; Image&lt;(L, Layer&lt;N&gt;)&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="layer"><a class="header" href="#layer">Layer</a></h3>
<p>A single image layer:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Layer&lt;Channels&gt; {
    /// Pixel data organized by channels
    pub channel_data: Channels,
    
    /// Layer-specific metadata
    pub attributes: LayerAttributes,
    
    /// Resolution (width, height)
    pub size: Vec2&lt;usize&gt;,
    
    /// How pixels are stored
    pub encoding: Encoding,
}

impl&lt;C&gt; Layer&lt;C&gt; {
    pub fn new(
        size: impl Into&lt;Vec2&lt;usize&gt;&gt;,
        attributes: LayerAttributes,
        encoding: Encoding,
        channels: C,
    ) -&gt; Self;
}
<span class="boring">}</span></code></pre>
<h3 id="encoding-1"><a class="header" href="#encoding-1">Encoding</a></h3>
<p>Storage format for pixels:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Encoding {
    pub compression: Compression,
    pub blocks: Blocks,
    pub line_order: LineOrder,
}

impl Encoding {
    /// Uncompressed
    pub const UNCOMPRESSED: Encoding;
    
    /// ZIP compression (fast + good compression)
    pub const FAST_LOSSLESS: Encoding;
    
    /// PIZ compression (best lossless)
    pub const SMALL_LOSSLESS: Encoding;
    
    /// B44 compression (fast lossy)
    pub const SMALL_LOSSY: Encoding;
}
<span class="boring">}</span></code></pre>
<h2 id="channel-types-2"><a class="header" href="#channel-types-2">Channel Types</a></h2>
<h3 id="anychannels"><a class="header" href="#anychannels">AnyChannels</a></h3>
<p>Dynamic list of channels:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnyChannels&lt;Samples&gt; {
    pub list: SmallVec&lt;[AnyChannel&lt;Samples&gt;; 4]&gt;,
}

impl&lt;S&gt; AnyChannels&lt;S&gt; {
    /// Create and sort by name
    pub fn sort(channels: SmallVec&lt;[AnyChannel&lt;S&gt;; 4]&gt;) -&gt; Self;
}
<span class="boring">}</span></code></pre>
<h3 id="anychannel"><a class="header" href="#anychannel">AnyChannel</a></h3>
<p>Single channel with any sample type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnyChannel&lt;Samples&gt; {
    pub name: Text,
    pub sample_data: Samples,
    pub quantize_linearly: bool,
    pub sampling: Vec2&lt;usize&gt;,
}

impl&lt;S&gt; AnyChannel&lt;S&gt; {
    pub fn new(name: impl Into&lt;Text&gt;, samples: S) -&gt; Self;
}
<span class="boring">}</span></code></pre>
<h3 id="specificchannels"><a class="header" href="#specificchannels">SpecificChannels</a></h3>
<p>Compile-time known channels:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SpecificChannels&lt;Pixels, ChannelDescriptions&gt; {
    pub channels: ChannelDescriptions,
    pub pixels: Pixels,
}

impl SpecificChannels&lt;(), ()&gt; {
    /// Start building specific channels
    pub fn build() -&gt; SpecificChannelsBuilder&lt;(), ()&gt;;
    
    /// RGBA channels
    pub fn rgba&lt;Px&gt;(
        get_pixel: impl Fn(Vec2&lt;usize&gt;) -&gt; Px
    ) -&gt; SpecificChannels&lt;impl GetPixel&lt;Pixel=Px&gt;, RgbaChannels&gt;;
    
    /// RGB channels
    pub fn rgb&lt;Px&gt;(
        get_pixel: impl Fn(Vec2&lt;usize&gt;) -&gt; Px
    ) -&gt; SpecificChannels&lt;impl GetPixel&lt;Pixel=Px&gt;, RgbChannels&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="specificchannelsbuilder"><a class="header" href="#specificchannelsbuilder">SpecificChannelsBuilder</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SpecificChannelsBuilder&lt;...&gt; {
    /// Add a channel
    pub fn with_channel(self, name: impl Into&lt;Text&gt;) -&gt; Self;
    
    /// Finalize with pixel function
    pub fn with_pixel_fn&lt;Px&gt;(
        self,
        get_pixel: impl Fn(Vec2&lt;usize&gt;) -&gt; Px
    ) -&gt; SpecificChannels&lt;...&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="sample-types-2"><a class="header" href="#sample-types-2">Sample Types</a></h2>
<h3 id="flatsamples"><a class="header" href="#flatsamples">FlatSamples</a></h3>
<p>One sample per pixel:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FlatSamples {
    F16(Vec&lt;f16&gt;),
    F32(Vec&lt;f32&gt;),
    U32(Vec&lt;u32&gt;),
}

impl FlatSamples {
    pub fn len(&amp;self) -&gt; usize;
    pub fn is_empty(&amp;self) -&gt; bool;
    pub fn sample_type(&amp;self) -&gt; SampleType;
}
<span class="boring">}</span></code></pre>
<h3 id="levels"><a class="header" href="#levels">Levels</a></h3>
<p>Multi-resolution samples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Levels&lt;S&gt; {
    Singular(S),
    Mip {
        rounding_mode: RoundingMode,
        level_data: LevelMaps&lt;S&gt;,
    },
    Rip {
        rounding_mode: RoundingMode,
        level_data: RipMaps&lt;S&gt;,
    },
}
<span class="boring">}</span></code></pre>
<h3 id="sample"><a class="header" href="#sample">Sample</a></h3>
<p>Dynamic sample value:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Sample {
    F16(f16),
    F32(f32),
    U32(u32),
}

impl Sample {
    pub fn to_f16(self) -&gt; f16;
    pub fn to_f32(self) -&gt; f32;
    pub fn to_u32(self) -&gt; u32;
}

impl From&lt;f16&gt; for Sample { ... }
impl From&lt;f32&gt; for Sample { ... }
impl From&lt;u32&gt; for Sample { ... }
<span class="boring">}</span></code></pre>
<h2 id="reading-1"><a class="header" href="#reading-1">Reading</a></h2>
<h3 id="read-entry-point"><a class="header" href="#read-entry-point">read() Entry Point</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read() -&gt; ReadBuilder;
<span class="boring">}</span></code></pre>
<h3 id="readbuilder"><a class="header" href="#readbuilder">ReadBuilder</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ReadBuilder {
    /// Skip deep data
    pub fn no_deep_data(self) -&gt; ReadFlatSamples;
    
    /// Read deep data
    pub fn any_deep_data(self) -&gt; ReadDeepSamples;
    
    /// Read either deep or flat
    pub fn flat_and_deep_data(self) -&gt; ReadAnySamples;
}
<span class="boring">}</span></code></pre>
<h3 id="readflatsamples"><a class="header" href="#readflatsamples">ReadFlatSamples</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ReadFlatSamples {
    /// Only largest resolution
    pub fn largest_resolution_level(self) -&gt; ReadLargestLevel;
    
    /// All mip/rip levels
    pub fn all_resolution_levels(self) -&gt; ReadAllLevels;
    
    /// Specific level by selector
    pub fn specific_resolution_level&lt;F&gt;(
        self, 
        selector: F
    ) -&gt; ReadSpecificLevel
    where F: FnOnce(Vec&lt;LevelInfo&gt;) -&gt; Vec2&lt;usize&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="readchannels"><a class="header" href="#readchannels">ReadChannels</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ReadChannels {
    /// All channels dynamically
    pub fn all_channels(self) -&gt; ReadAnyChannels;
    
    /// RGBA with custom storage
    pub fn rgba_channels&lt;C, S&gt;(
        self,
        constructor: C,
        setter: S,
    ) -&gt; ReadRgbaChannels;
    
    /// RGB with custom storage
    pub fn rgb_channels&lt;C, S&gt;(...) -&gt; ReadRgbChannels;
    
    /// Custom channel set
    pub fn specific_channels(self) -&gt; ReadSpecificChannels;
}
<span class="boring">}</span></code></pre>
<h3 id="readlayers"><a class="header" href="#readlayers">ReadLayers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ReadLayers {
    /// First layer matching requirements
    pub fn first_valid_layer(self) -&gt; ReadFirstLayer;
    
    /// All layers
    pub fn all_layers(self) -&gt; ReadAllLayers;
    
    /// All layers matching requirements
    pub fn all_valid_layers(self) -&gt; ReadAllValidLayers;
}
<span class="boring">}</span></code></pre>
<h3 id="final-read"><a class="header" href="#final-read">Final Read</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ReadImage {
    /// Load all attributes
    pub fn all_attributes(self) -&gt; ReadWithAttributes;
}

impl ReadWithAttributes {
    /// Progress callback
    pub fn on_progress(self, callback: impl FnMut(f64)) -&gt; Self;
    
    /// Disable parallel decompression
    pub fn non_parallel(self) -&gt; Self;
    
    /// Strict validation
    pub fn pedantic(self) -&gt; Self;
    
    /// Read from file
    pub fn from_file(self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Image&lt;...&gt;&gt;;
    
    /// Read from buffered reader
    pub fn from_buffered(self, reader: impl Read) -&gt; Result&lt;Image&lt;...&gt;&gt;;
    
    /// Read from unbuffered reader
    pub fn from_unbuffered(self, reader: impl Read) -&gt; Result&lt;Image&lt;...&gt;&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="writing-1"><a class="header" href="#writing-1">Writing</a></h2>
<h3 id="imagewrite-1"><a class="header" href="#imagewrite-1">Image::write()</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;L: WritableImage&gt; Image&lt;L&gt; {
    pub fn write(self) -&gt; WriteImageWithOptions&lt;L&gt;;
}

impl&lt;L&gt; WriteImageWithOptions&lt;L&gt; {
    /// Progress callback
    pub fn on_progress(self, callback: impl FnMut(f64)) -&gt; Self;
    
    /// Disable parallel compression
    pub fn non_parallel(self) -&gt; Self;
    
    /// Write to file
    pub fn to_file(self, path: impl AsRef&lt;Path&gt;) -&gt; UnitResult;
    
    /// Write to buffered writer
    pub fn to_buffered(self, writer: impl Write + Seek) -&gt; UnitResult;
    
    /// Write to unbuffered writer
    pub fn to_unbuffered(self, writer: impl Write + Seek) -&gt; UnitResult;
}
<span class="boring">}</span></code></pre>
<h2 id="cropping"><a class="header" href="#cropping">Cropping</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Crop&lt;Sample&gt; {
    type Cropped;
    
    fn crop(
        self, 
        should_crop: impl FnMut(&amp;Sample) -&gt; bool
    ) -&gt; CropResult&lt;Self::Cropped&gt;;
}

pub enum CropResult&lt;T&gt; {
    Cropped {
        result: T,
        data_window_offset: Vec2&lt;i32&gt;,
    },
    Empty,
}
<span class="boring">}</span></code></pre>
<h2 id="pixel-storage"><a class="header" href="#pixel-storage">Pixel Storage</a></h2>
<h3 id="pixelvec"><a class="header" href="#pixelvec">PixelVec</a></h3>
<p>Simple pixel storage:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PixelVec&lt;Pixel&gt; {
    pub resolution: Vec2&lt;usize&gt;,
    pub pixels: Vec&lt;Pixel&gt;,
}

impl&lt;P: Default + Clone&gt; PixelVec&lt;P&gt; {
    pub fn constructor(resolution: Vec2&lt;usize&gt;, _: &amp;C) -&gt; Self;
    pub fn set_pixel(&amp;mut self, position: Vec2&lt;usize&gt;, pixel: P);
}
<span class="boring">}</span></code></pre>
<h3 id="getpixel-trait"><a class="header" href="#getpixel-trait">GetPixel Trait</a></h3>
<p>For writing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait GetPixel {
    type Pixel;
    fn get_pixel(&amp;self, position: Vec2&lt;usize&gt;) -&gt; Self::Pixel;
}
<span class="boring">}</span></code></pre>
<h2 id="levelinfo"><a class="header" href="#levelinfo">LevelInfo</a></h2>
<p>For resolution level selection:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LevelInfo {
    /// Level index (x, y)
    pub index: Vec2&lt;usize&gt;,
    
    /// Resolution at this level
    pub resolution: Vec2&lt;usize&gt;,
}
<span class="boring">}</span></code></pre>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See Also</a></h2>
<ul>
<li><a href="#prelude">Prelude</a> - Common re-exports</li>
<li><a href="#meta-module">Meta Module</a> - Metadata types</li>
<li><a href="#deep-data-module">Deep Data API</a> - Deep data specifics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="meta-module"><a class="header" href="#meta-module">Meta Module</a></h1>
<p>The <code>exr::meta</code> module contains metadata types for EXR files.</p>
<h2 id="metadata-2"><a class="header" href="#metadata-2">MetaData</a></h2>
<p>Complete file metadata:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MetaData {
    /// File requirements and version
    pub requirements: Requirements,
    
    /// Headers (one per layer)
    pub headers: Headers,
}
<span class="boring">}</span></code></pre>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>File format requirements:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Requirements {
    /// Format version (usually 2)
    pub file_format_version: u8,
    
    /// Single-part file
    pub is_single_part: bool,
    
    /// Contains deep data
    pub has_deep_data: bool,
    
    /// Has long channel/attribute names
    pub has_long_names: bool,
}
<span class="boring">}</span></code></pre>
<h2 id="header"><a class="header" href="#header">Header</a></h2>
<p>Per-layer header:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Header {
    /// Channel definitions
    pub channels: ChannelList,
    
    /// Compression method
    pub compression: Compression,
    
    /// Pixel data dimensions
    pub data_size: Vec2&lt;usize&gt;,
    
    /// Block organization
    pub blocks: BlockDescription,
    
    /// Layer attributes
    pub layer_attributes: LayerAttributes,
    
    /// Shared image attributes (Arc for multipart)
    pub shared_attributes: Option&lt;Arc&lt;ImageAttributes&gt;&gt;,
    
    /// Deep data flag
    pub deep: bool,
    
    /// Deep data type
    pub deep_data_version: Option&lt;i32&gt;,
    
    /// Maximum samples per pixel (deep)
    pub max_samples_per_pixel: Option&lt;usize&gt;,
}
<span class="boring">}</span></code></pre>
<h2 id="imageattributes"><a class="header" href="#imageattributes">ImageAttributes</a></h2>
<p>Image-level metadata:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ImageAttributes {
    /// Display bounds (full frame)
    pub display_window: IntegerBounds,
    
    /// Pixel aspect ratio
    pub pixel_aspect: f32,
    
    /// Color space primaries
    pub chromaticities: Option&lt;Chromaticities&gt;,
    
    /// SMPTE timecode
    pub time_code: Option&lt;TimeCode&gt;,
    
    /// Custom attributes
    pub other: HashMap&lt;Text, AttributeValue&gt;,
}

impl ImageAttributes {
    pub fn new(display_window: IntegerBounds) -&gt; Self;
    
    pub fn with_size(size: impl Into&lt;Vec2&lt;usize&gt;&gt;) -&gt; Self;
}
<span class="boring">}</span></code></pre>
<h2 id="layerattributes"><a class="header" href="#layerattributes">LayerAttributes</a></h2>
<p>Layer-level metadata:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LayerAttributes {
    /// Layer name (required for multipart)
    pub layer_name: Option&lt;Text&gt;,
    
    /// Layer position offset
    pub layer_position: Vec2&lt;i32&gt;,
    
    /// Screen window center
    pub screen_window_center: Vec2&lt;f32&gt;,
    
    /// Screen window width
    pub screen_window_width: f32,
    
    /// White luminance (cd/m^2)
    pub white_luminance: Option&lt;f32&gt;,
    
    /// Adopted neutral
    pub adopted_neutral: Option&lt;Vec2&lt;f32&gt;&gt;,
    
    /// Rendering transform
    pub rendering_transform_name: Option&lt;Text&gt;,
    
    /// Look modification transform
    pub look_modification_transform_name: Option&lt;Text&gt;,
    
    /// X density (pixels per inch)
    pub horizontal_density: Option&lt;f32&gt;,
    
    /// Copyright owner
    pub owner: Option&lt;Text&gt;,
    
    /// Comments
    pub comments: Option&lt;Text&gt;,
    
    /// Capture date
    pub capture_date: Option&lt;Text&gt;,
    
    /// UTC offset
    pub utc_offset: Option&lt;f32&gt;,
    
    /// Longitude
    pub longitude: Option&lt;f32&gt;,
    
    /// Latitude
    pub latitude: Option&lt;f32&gt;,
    
    /// Altitude
    pub altitude: Option&lt;f32&gt;,
    
    /// Focus distance (meters)
    pub focus: Option&lt;f32&gt;,
    
    /// Exposure time (seconds)
    pub exposure: Option&lt;f32&gt;,
    
    /// Aperture
    pub aperture: Option&lt;f32&gt;,
    
    /// ISO speed
    pub iso_speed: Option&lt;f32&gt;,
    
    /// Environment map type
    pub environment_map: Option&lt;EnvironmentMap&gt;,
    
    /// Key code (film)
    pub key_code: Option&lt;KeyCode&gt;,
    
    /// Wrap modes
    pub wrap_mode_name: Option&lt;Text&gt;,
    
    /// Frames per second
    pub frames_per_second: Option&lt;Rational&gt;,
    
    /// Multi-view name
    pub multi_view: Option&lt;Text&gt;,
    
    /// World-to-camera matrix
    pub world_to_camera: Option&lt;Matrix4x4&gt;,
    
    /// World-to-NDC matrix
    pub world_to_normalized_device: Option&lt;Matrix4x4&gt;,
    
    /// Deep image state
    pub deep_image_state: Option&lt;f32&gt;,
    
    /// Original data window
    pub original_data_window: Option&lt;IntegerBounds&gt;,
    
    /// DWA compression level
    pub dwa_compression_level: Option&lt;f32&gt;,
    
    /// Preview image
    pub preview: Option&lt;Preview&gt;,
    
    /// View name
    pub view: Option&lt;Text&gt;,
    
    /// Software name
    pub software_name: Option&lt;Text&gt;,
    
    /// Near clip
    pub near_clip_plane: Option&lt;f32&gt;,
    
    /// Far clip
    pub far_clip_plane: Option&lt;f32&gt;,
    
    /// Field of view (horizontal)
    pub horizontal_field_of_view: Option&lt;f32&gt;,
    
    /// Field of view (vertical)
    pub vertical_field_of_view: Option&lt;f32&gt;,
    
    /// Custom attributes
    pub other: HashMap&lt;Text, AttributeValue&gt;,
}

impl LayerAttributes {
    /// Create with name
    pub fn named(name: impl Into&lt;Text&gt;) -&gt; Self;
    
    /// Create with default values
    pub fn new(name: impl Into&lt;Text&gt;) -&gt; Self;
}
<span class="boring">}</span></code></pre>
<h2 id="channeldescription"><a class="header" href="#channeldescription">ChannelDescription</a></h2>
<p>Single channel definition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ChannelDescription {
    /// Channel name
    pub name: Text,
    
    /// Sample type
    pub sample_type: SampleType,
    
    /// Linear quantization flag
    pub quantize_linearly: bool,
    
    /// Subsampling rate
    pub sampling: Vec2&lt;usize&gt;,
}

impl ChannelDescription {
    pub fn new(name: impl Into&lt;Text&gt;, sample_type: SampleType) -&gt; Self;
}
<span class="boring">}</span></code></pre>
<h2 id="sampletype"><a class="header" href="#sampletype">SampleType</a></h2>
<p>Pixel sample types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SampleType {
    U32,
    F16,
    F32,
}

impl SampleType {
    pub fn bytes_per_sample(self) -&gt; usize;
}
<span class="boring">}</span></code></pre>
<h2 id="compression-2"><a class="header" href="#compression-2">Compression</a></h2>
<p>Compression methods:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Compression {
    /// No compression
    Uncompressed,
    
    /// Run-length encoding
    RLE,
    
    /// ZIP (single scanline)
    ZIPS,
    
    /// ZIP (16 scanlines)
    ZIP,
    
    /// Wavelet (32 scanlines)
    PIZ,
    
    /// 24-bit float (16 scanlines)
    PXR24,
    
    /// Block compression
    B44,
    
    /// Block compression (sparse)
    B44A,
    
    /// DCT (32 scanlines) - not implemented
    DWAA,
    
    /// DCT (256 scanlines) - not implemented
    DWAB,
}

impl Compression {
    /// Scanlines per block
    pub fn scan_lines_per_block(self) -&gt; usize;
    
    /// Is lossless
    pub fn is_lossless(self) -&gt; bool;
    
    /// Supports deep data
    pub fn supports_deep_data(self) -&gt; bool;
}
<span class="boring">}</span></code></pre>
<h2 id="lineorder"><a class="header" href="#lineorder">LineOrder</a></h2>
<p>Scanline ordering:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum LineOrder {
    /// Top to bottom
    Increasing,
    
    /// Bottom to top
    Decreasing,
    
    /// Any order
    Unspecified,
}
<span class="boring">}</span></code></pre>
<h2 id="tiledescription"><a class="header" href="#tiledescription">TileDescription</a></h2>
<p>Tile configuration:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TileDescription {
    /// Tile size
    pub tile_size: Vec2&lt;usize&gt;,
    
    /// Level mode
    pub level_mode: LevelMode,
    
    /// Rounding mode
    pub rounding_mode: RoundingMode,
}

pub enum LevelMode {
    Singular,
    MipMap,
    RipMap,
}

pub enum RoundingMode {
    Up,
    Down,
}
<span class="boring">}</span></code></pre>
<h2 id="integerbounds"><a class="header" href="#integerbounds">IntegerBounds</a></h2>
<p>Rectangle with position:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntegerBounds {
    /// Top-left position
    pub position: Vec2&lt;i32&gt;,
    
    /// Size
    pub size: Vec2&lt;usize&gt;,
}

impl IntegerBounds {
    pub fn from_dimensions(size: impl Into&lt;Vec2&lt;usize&gt;&gt;) -&gt; Self;
    
    pub fn zero_min_with_size(size: impl Into&lt;Vec2&lt;usize&gt;&gt;) -&gt; Self;
    
    pub fn end(&amp;self) -&gt; Vec2&lt;i32&gt;;
    
    pub fn contains(&amp;self, position: Vec2&lt;i32&gt;) -&gt; bool;
}
<span class="boring">}</span></code></pre>
<h2 id="text"><a class="header" href="#text">Text</a></h2>
<p>UTF-8 string optimized for small names:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Text(SmallVec&lt;[u8; 24]&gt;);

impl Text {
    pub fn from_str_unchecked(text: &amp;str) -&gt; Self;
    pub fn new_or_none(text: &amp;str) -&gt; Option&lt;Self&gt;;
    pub fn new_or_panic(text: &amp;str) -&gt; Self;
    pub fn as_str(&amp;self) -&gt; &amp;str;
    pub fn is_empty(&amp;self) -&gt; bool;
}

impl From&lt;&amp;str&gt; for Text { ... }
impl From&lt;String&gt; for Text { ... }
<span class="boring">}</span></code></pre>
<h2 id="attributevalue"><a class="header" href="#attributevalue">AttributeValue</a></h2>
<p>Attribute value types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AttributeValue {
    I32(i32),
    F32(f32),
    F64(f64),
    Rational(Rational),
    
    Text(Text),
    TextVector(Vec&lt;Text&gt;),
    
    IntVec2(Vec2&lt;i32&gt;),
    FloatVec2(Vec2&lt;f32&gt;),
    IntVec3((i32, i32, i32)),
    FloatVec3((f32, f32, f32)),
    
    IntRect(IntegerBounds),
    FloatRect(FloatRect),
    
    ChannelList(ChannelList),
    
    Chromaticities(Chromaticities),
    Compression(Compression),
    EnvironmentMap(EnvironmentMap),
    KeyCode(KeyCode),
    LineOrder(LineOrder),
    Matrix3x3([f32; 9]),
    Matrix4x4([f32; 16]),
    Preview(Preview),
    TileDescription(TileDescription),
    TimeCode(TimeCode),
    
    /// Custom/unknown attribute
    Custom {
        type_name: Text,
        bytes: Vec&lt;u8&gt;,
    },
}
<span class="boring">}</span></code></pre>
<h2 id="chromaticities"><a class="header" href="#chromaticities">Chromaticities</a></h2>
<p>Color space definition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Chromaticities {
    pub red: Vec2&lt;f32&gt;,
    pub green: Vec2&lt;f32&gt;,
    pub blue: Vec2&lt;f32&gt;,
    pub white: Vec2&lt;f32&gt;,
}

impl Chromaticities {
    /// sRGB/Rec.709
    pub const SRGB: Chromaticities;
    
    /// Adobe RGB
    pub const ADOBE_RGB: Chromaticities;
    
    /// DCI-P3
    pub const DCI_P3: Chromaticities;
}
<span class="boring">}</span></code></pre>
<h2 id="timecode"><a class="header" href="#timecode">TimeCode</a></h2>
<p>SMPTE timecode:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TimeCode {
    pub hours: u8,
    pub minutes: u8,
    pub seconds: u8,
    pub frame: u8,
    pub drop_frame: bool,
    pub color_frame: bool,
    pub field_phase: bool,
    pub binary_group_flags: [bool; 3],
    pub binary_groups: [u8; 8],
}
<span class="boring">}</span></code></pre>
<h2 id="preview"><a class="header" href="#preview">Preview</a></h2>
<p>Thumbnail image:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Preview {
    pub width: u32,
    pub height: u32,
    pub pixels: Vec&lt;(u8, u8, u8, u8)&gt;,  // RGBA
}
<span class="boring">}</span></code></pre>
<h2 id="see-also-12"><a class="header" href="#see-also-12">See Also</a></h2>
<ul>
<li><a href="#prelude">Prelude</a> - Common exports</li>
<li><a href="#image-module">Image Module</a> - High-level API</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="block-module"><a class="header" href="#block-module">Block Module</a></h1>
<p>The <code>exr::block</code> module provides low-level access to EXR pixel blocks.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Use this module when you need:</p>
<ul>
<li>Custom compression handling</li>
<li>Streaming processing</li>
<li>Direct block manipulation</li>
<li>Memory-constrained environments</li>
</ul>
<h2 id="blockindex"><a class="header" href="#blockindex">BlockIndex</a></h2>
<p>Identifies a block within an image:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BlockIndex {
    /// Layer index (for multipart)
    pub layer: usize,
    
    /// Mip/rip level
    pub level: Vec2&lt;usize&gt;,
    
    /// Block position in pixels
    pub pixel_position: Vec2&lt;usize&gt;,
    
    /// Block size in pixels
    pub pixel_size: Vec2&lt;usize&gt;,
}
<span class="boring">}</span></code></pre>
<h2 id="uncompressedblock"><a class="header" href="#uncompressedblock">UncompressedBlock</a></h2>
<p>Decompressed pixel data:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UncompressedBlock {
    /// Block identification
    pub index: BlockIndex,
    
    /// Raw pixel bytes (native endian)
    pub data: Vec&lt;u8&gt;,
}

impl UncompressedBlock {
    /// Decompress from chunk
    pub fn decompress_chunk(
        chunk: Chunk,
        meta_data: &amp;MetaData,
        pedantic: bool,
    ) -&gt; Result&lt;Self&gt;;
    
    /// Compress to chunk
    pub fn compress_to_chunk(
        &amp;self,
        headers: &amp;Headers,
    ) -&gt; Result&lt;Chunk&gt;;
    
    /// Iterate lines
    pub fn lines(&amp;self, channels: &amp;ChannelList) -&gt; impl Iterator&lt;Item = LineRef&gt;;
    
    /// Mutable line access
    pub fn lines_mut(&amp;mut self, channels: &amp;ChannelList) -&gt; impl Iterator&lt;Item = LineRefMut&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="chunk"><a class="header" href="#chunk">Chunk</a></h2>
<p>Compressed block data:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Chunk {
    /// Layer this chunk belongs to
    pub layer_index: usize,
    
    /// Compressed data
    pub compressed_block: CompressedBlock,
}

pub enum CompressedBlock {
    /// Flat scanline block
    ScanLine {
        y_coordinate: i32,
        compressed_pixels: Vec&lt;u8&gt;,
    },
    
    /// Flat tile block
    Tile {
        tile_position: Vec2&lt;usize&gt;,
        level: Vec2&lt;usize&gt;,
        compressed_pixels: Vec&lt;u8&gt;,
    },
    
    /// Deep scanline block
    DeepScanLine {
        y_coordinate: i32,
        compressed_sample_offset_table: Vec&lt;u8&gt;,
        compressed_samples: Vec&lt;u8&gt;,
        decompressed_samples_byte_count: usize,
    },
    
    /// Deep tile block
    DeepTile {
        tile_position: Vec2&lt;usize&gt;,
        level: Vec2&lt;usize&gt;,
        compressed_sample_offset_table: Vec&lt;u8&gt;,
        compressed_samples: Vec&lt;u8&gt;,
        decompressed_samples_byte_count: usize,
    },
}
<span class="boring">}</span></code></pre>
<h2 id="reading-2"><a class="header" href="#reading-2">Reading</a></h2>
<h3 id="reader"><a class="header" href="#reader">Reader</a></h3>
<p>Low-level file reader:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Reader&lt;R&gt; {
    meta_data: MetaData,
    // ...
}

impl&lt;R: Read + Seek&gt; Reader&lt;R&gt; {
    /// Read from file
    pub fn read_from_file(
        path: impl AsRef&lt;Path&gt;,
        pedantic: bool,
    ) -&gt; Result&lt;Self&gt;;
    
    /// Read from buffered reader
    pub fn read_from_buffered(
        read: R,
        pedantic: bool,
    ) -&gt; Result&lt;Self&gt;;
    
    /// Get metadata
    pub fn meta_data(&amp;self) -&gt; &amp;MetaData;
    
    /// Get all chunks iterator
    pub fn all_chunks(self, pedantic: bool) -&gt; ChunksReader&lt;R&gt;;
    
    /// Decompress all blocks in parallel
    pub fn decompress_parallel(
        self,
        pedantic: bool,
    ) -&gt; ParallelBlockDecompressor&lt;R&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="chunksreader"><a class="header" href="#chunksreader">ChunksReader</a></h3>
<p>Iterator over chunks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ChunksReader&lt;R&gt; { /* ... */ }

impl&lt;R: Read&gt; Iterator for ChunksReader&lt;R&gt; {
    type Item = Result&lt;Chunk&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="parallelblockdecompressor"><a class="header" href="#parallelblockdecompressor">ParallelBlockDecompressor</a></h3>
<p>Parallel decompression:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ParallelBlockDecompressor&lt;R&gt; { /* ... */ }

impl&lt;R: Read + Send&gt; Iterator for ParallelBlockDecompressor&lt;R&gt; {
    type Item = Result&lt;UncompressedBlock&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="writing-2"><a class="header" href="#writing-2">Writing</a></h2>
<h3 id="blockwrite"><a class="header" href="#blockwrite">block::write()</a></h3>
<p>Entry point for writing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn write&lt;W: Write + Seek&gt;(
    write: W,
    headers: Headers,
    pedantic: bool,
    write_chunks: impl FnOnce(MetaData, &amp;mut ChunksWriter&lt;W&gt;) -&gt; UnitResult,
) -&gt; UnitResult;
<span class="boring">}</span></code></pre>
<h3 id="chunkswriter"><a class="header" href="#chunkswriter">ChunksWriter</a></h3>
<p>Write chunks to file:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ChunksWriter&lt;W&gt; { /* ... */ }

impl&lt;W: Write + Seek&gt; ChunksWriter&lt;W&gt; {
    /// Write a single chunk
    pub fn write_chunk(&amp;mut self, chunk: Chunk) -&gt; UnitResult;
    
    /// Compress and write all blocks sequentially
    pub fn compress_all_blocks_sequential&lt;B&gt;(
        &amp;mut self,
        headers: &amp;Headers,
        blocks: B,
    ) -&gt; UnitResult
    where
        B: Iterator&lt;Item = UncompressedBlock&gt;;
    
    /// Compress and write all blocks in parallel
    #[cfg(feature = "rayon")]
    pub fn compress_all_blocks_parallel&lt;B&gt;(
        &amp;mut self,
        headers: &amp;Headers,
        blocks: B,
    ) -&gt; UnitResult
    where
        B: Iterator&lt;Item = UncompressedBlock&gt; + Send;
}
<span class="boring">}</span></code></pre>
<h2 id="lines"><a class="header" href="#lines">Lines</a></h2>
<h3 id="lineindex"><a class="header" href="#lineindex">LineIndex</a></h3>
<p>Line identification:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LineIndex {
    /// Channel index
    pub channel: usize,
    
    /// Y position within block
    pub position: Vec2&lt;usize&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="lineref--linerefmut"><a class="header" href="#lineref--linerefmut">LineRef / LineRefMut</a></h3>
<p>Line access:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LineRef&lt;'a&gt; {
    pub index: LineIndex,
    pub data: &amp;'a [u8],
}

pub struct LineRefMut&lt;'a&gt; {
    pub index: LineIndex,
    pub data: &amp;'a mut [u8],
}
<span class="boring">}</span></code></pre>
<h2 id="sample-types-3"><a class="header" href="#sample-types-3">Sample Types</a></h2>
<h3 id="sample-1"><a class="header" href="#sample-1">Sample</a></h3>
<p>Dynamic sample value:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Sample {
    F16(f16),
    F32(f32),
    U32(u32),
}

impl Sample {
    /// Convert to f16
    pub fn to_f16(self) -&gt; f16;
    
    /// Convert to f32
    pub fn to_f32(self) -&gt; f32;
    
    /// Convert to u32
    pub fn to_u32(self) -&gt; u32;
    
    /// Check if NaN
    pub fn is_nan(self) -&gt; bool;
    
    /// Check if infinite
    pub fn is_infinite(self) -&gt; bool;
}
<span class="boring">}</span></code></pre>
<h2 id="deep-blocks"><a class="header" href="#deep-blocks">Deep Blocks</a></h2>
<h3 id="deepuncompressedblock"><a class="header" href="#deepuncompressedblock">DeepUncompressedBlock</a></h3>
<p>Decompressed deep data:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DeepUncompressedBlock {
    pub index: BlockIndex,
    pub samples: DeepSamples,
}
<span class="boring">}</span></code></pre>
<h3 id="deep-decompression"><a class="header" href="#deep-decompression">Deep Decompression</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn decompress_deep_scanline_block(
    chunk: &amp;Chunk,
    header: &amp;Header,
    pedantic: bool,
) -&gt; Result&lt;DeepUncompressedBlock&gt;;

pub fn decompress_deep_tile_block(
    chunk: &amp;Chunk,
    header: &amp;Header,
    pedantic: bool,
) -&gt; Result&lt;DeepUncompressedBlock&gt;;
<span class="boring">}</span></code></pre>
<h2 id="example-custom-reading"><a class="header" href="#example-custom-reading">Example: Custom Reading</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::block::{self, Reader, UncompressedBlock};

fn custom_read(path: &amp;str) -&gt; Result&lt;(), exr::error::Error&gt; {
    let reader = Reader::read_from_file(path, false)?;
    let meta = reader.meta_data().clone();
    
    for chunk_result in reader.all_chunks(false) {
        let chunk = chunk_result?;
        let block = UncompressedBlock::decompress_chunk(chunk, &amp;meta, false)?;
        
        println!("Block at {:?}, size {:?}", 
            block.index.pixel_position,
            block.index.pixel_size);
        
        // Access lines
        for line in block.lines(&amp;meta.headers[block.index.layer].channels) {
            println!("  Channel {}, y={}, {} bytes",
                line.index.channel,
                line.index.position.y(),
                line.data.len());
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="example-custom-writing"><a class="header" href="#example-custom-writing">Example: Custom Writing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exr::block::{self, UncompressedBlock, BlockIndex};
use exr::meta::{Header, MetaData};

fn custom_write(path: &amp;str, headers: Vec&lt;Header&gt;) -&gt; UnitResult {
    let file = std::fs::File::create(path)?;
    
    block::write(
        file,
        headers.into(),
        true,  // pedantic
        |meta, writer| {
            // Generate blocks
            for layer_index in 0..meta.headers.len() {
                let header = &amp;meta.headers[layer_index];
                
                for y in (0..header.data_size.height())
                    .step_by(header.compression.scan_lines_per_block())
                {
                    let block = generate_block(layer_index, y, header);
                    let chunk = block.compress_to_chunk(&amp;meta.headers)?;
                    writer.write_chunk(chunk)?;
                }
            }
            Ok(())
        }
    )
}
<span class="boring">}</span></code></pre>
<h2 id="see-also-13"><a class="header" href="#see-also-13">See Also</a></h2>
<ul>
<li><a href="#compression-module">Compression Module</a> - Compression algorithms</li>
<li><a href="#deep-data-module">Deep Data API</a> - Deep block handling</li>
<li><a href="#data-flow-1">Developer Guide: Data Flow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="compression-module"><a class="header" href="#compression-module">Compression Module</a></h1>
<p>Low-level compression and decompression for EXR pixel data.</p>
<h2 id="module-exrscompression"><a class="header" href="#module-exrscompression">Module: <code>exrs::compression</code></a></h2>
<h3 id="compression-enum"><a class="header" href="#compression-enum">Compression Enum</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Compression {
    /// No compression
    Uncompressed,
    
    /// Run-length encoding (lossless)
    RLE,
    
    /// Zip compression, 1 scanline per block (lossless)
    ZIP1,
    
    /// Zip compression, 16 scanlines per block (lossless)
    ZIP16,
    
    /// Wavelet-based compression (lossless)
    PIZ,
    
    /// Lossy DCT-based compression (24-bit)
    PXR24,
    
    /// Lossy fixed-rate compression
    B44,
    
    /// B44 with improved handling of flat areas
    B44A,
    
    /// DWAA - lossy compression, 32 scanlines
    DWAA(Option&lt;f32&gt;),
    
    /// DWAB - lossy compression, 256 scanlines
    DWAB(Option&lt;f32&gt;),
}
<span class="boring">}</span></code></pre>
<h3 id="compression-methods-1"><a class="header" href="#compression-methods-1">Compression Methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Compression {
    /// Returns true if compression is lossless
    pub fn is_lossless(&amp;self) -&gt; bool;
    
    /// Returns true if compression may lose data
    pub fn is_lossy(&amp;self) -&gt; bool;
    
    /// Number of scanlines per compressed block
    pub fn scan_lines_per_block(&amp;self) -&gt; usize;
    
    /// Whether this compression supports deep data
    pub fn supports_deep_data(&amp;self) -&gt; bool;
}
<span class="boring">}</span></code></pre>
<h2 id="compression-selection-guide"><a class="header" href="#compression-selection-guide">Compression Selection Guide</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Compression</th><th>Type</th><th>Speed</th><th>Ratio</th><th>Deep Support</th></tr>
</thead>
<tbody>
<tr><td>Uncompressed</td><td>-</td><td>Fastest</td><td>1:1</td><td>Yes</td></tr>
<tr><td>RLE</td><td>Lossless</td><td>Fast</td><td>Low</td><td>Yes</td></tr>
<tr><td>ZIP1</td><td>Lossless</td><td>Medium</td><td>Good</td><td>Yes</td></tr>
<tr><td>ZIP16</td><td>Lossless</td><td>Medium</td><td>Better</td><td>Yes</td></tr>
<tr><td>PIZ</td><td>Lossless</td><td>Slow</td><td>Best</td><td>No</td></tr>
<tr><td>PXR24</td><td>Lossy</td><td>Fast</td><td>Good</td><td>No</td></tr>
<tr><td>B44/B44A</td><td>Lossy</td><td>Fast</td><td>Fixed</td><td>No</td></tr>
<tr><td>DWAA/DWAB</td><td>Lossy</td><td>Medium</td><td>Excellent</td><td>No</td></tr>
</tbody>
</table>
</div>
<h2 id="internal-functions"><a class="header" href="#internal-functions">Internal Functions</a></h2>
<h3 id="compress"><a class="header" href="#compress">Compress</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compress(
    compression: Compression,
    bytes: ByteVec,
    rectangle: IntegerBounds,
    channels: &amp;[ChannelDescription],
) -&gt; Result&lt;ByteVec&gt;;
<span class="boring">}</span></code></pre>
<p>Compresses raw pixel data using the specified algorithm.</p>
<h3 id="decompress"><a class="header" href="#decompress">Decompress</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn decompress(
    compression: Compression,
    compressed: ByteVec,
    rectangle: IntegerBounds,
    channels: &amp;[ChannelDescription],
    expected_byte_size: usize,
    pedantic: bool,
) -&gt; Result&lt;ByteVec&gt;;
<span class="boring">}</span></code></pre>
<p>Decompresses pixel data back to raw bytes.</p>
<h2 id="algorithm-details"><a class="header" href="#algorithm-details">Algorithm Details</a></h2>
<h3 id="zip-deflate"><a class="header" href="#zip-deflate">ZIP (Deflate)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ZIP uses zlib deflate compression
// ZIP1: 1 scanline per block - lower latency
// ZIP16: 16 scanlines per block - better compression
<span class="boring">}</span></code></pre>
<h3 id="piz-wavelet"><a class="header" href="#piz-wavelet">PIZ (Wavelet)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PIZ uses Haar wavelet transform + Huffman coding
// Best lossless compression ratio
// Slower than ZIP
// Not suitable for deep data
<span class="boring">}</span></code></pre>
<h3 id="rle-run-length"><a class="header" href="#rle-run-length">RLE (Run-Length)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple run-length encoding
// Fast compression/decompression
// Good for images with large flat areas
// Supports deep data
<span class="boring">}</span></code></pre>
<h3 id="pxr24-lossy-24-bit"><a class="header" href="#pxr24-lossy-24-bit">PXR24 (Lossy 24-bit)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Converts 32-bit float to 24-bit
// Loses ~1 bit of precision
// Good for display-ready images
<span class="boring">}</span></code></pre>
<h3 id="b44b44a-fixed-rate"><a class="header" href="#b44b44a-fixed-rate">B44/B44A (Fixed Rate)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fixed 4:1 compression ratio (4.54:1 with alpha)
// B44A handles flat areas better
// Good for real-time playback
<span class="boring">}</span></code></pre>
<h3 id="dwaadwab-dct-based"><a class="header" href="#dwaadwab-dct-based">DWAA/DWAB (DCT-based)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lossy DCT compression similar to JPEG
// Configurable quality via compression level
// DWAA: 32 scanlines per block
// DWAB: 256 scanlines per block (better ratio)
<span class="boring">}</span></code></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="setting-compression-on-write"><a class="header" href="#setting-compression-on-write">Setting Compression on Write</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exrs::prelude::*;

let image = Image::from_channels(
    (1920, 1080),
    SpecificChannels::rgba(|pos| {
        // pixel data...
        (1.0f32, 0.5, 0.0, 1.0)
    })
);

image.write()
    .to_file("output.exr")?;

// Or with specific compression:
image.write()
    .to_file("output_piz.exr")?; // Default is ZIP
<span class="boring">}</span></code></pre>
<h3 id="checking-compression-type"><a class="header" href="#checking-compression-type">Checking Compression Type</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exrs::prelude::*;
use exrs::meta::header::Header;

let meta = MetaData::read_from_file("image.exr", false)?;
for header in &amp;meta.headers {
    println!("Compression: {:?}", header.compression);
    println!("Lossless: {}", header.compression.is_lossless());
}
<span class="boring">}</span></code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<ol>
<li><strong>For archival</strong>: Use PIZ (best lossless ratio)</li>
<li><strong>For speed</strong>: Use ZIP1 or RLE</li>
<li><strong>For streaming</strong>: Use Uncompressed or RLE</li>
<li><strong>For deep data</strong>: Use ZIP16 or RLE (PIZ not supported)</li>
<li><strong>For playback</strong>: Use B44/B44A (fixed decode time)</li>
</ol>
<h2 id="parallel-decompression-2"><a class="header" href="#parallel-decompression-2">Parallel Decompression</a></h2>
<p>The library uses Rayon for parallel decompression:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Blocks are decompressed in parallel automatically
// Configure thread pool via rayon's global thread pool
rayon::ThreadPoolBuilder::new()
    .num_threads(8)
    .build_global()
    .unwrap();
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="deep-data-module"><a class="header" href="#deep-data-module">Deep Data Module</a></h1>
<p>API reference for deep data (OpenEXR 2.0) support.</p>
<h2 id="core-types-1"><a class="header" href="#core-types-1">Core Types</a></h2>
<h3 id="deepsamples"><a class="header" href="#deepsamples">DeepSamples</a></h3>
<p>Variable-length sample storage per pixel:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum DeepSamples&lt;T&gt; {
    /// Flat data (1 sample per pixel)
    Flat(Vec&lt;T&gt;),
    
    /// Deep data (variable samples per pixel)
    Deep {
        /// Sample counts per pixel
        sample_counts: Vec&lt;u32&gt;,
        /// All samples flattened
        samples: Vec&lt;T&gt;,
    },
}
<span class="boring">}</span></code></pre>
<h3 id="deepsamples-methods"><a class="header" href="#deepsamples-methods">DeepSamples Methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; DeepSamples&lt;T&gt; {
    /// Create deep samples from counts and data
    pub fn deep(sample_counts: Vec&lt;u32&gt;, samples: Vec&lt;T&gt;) -&gt; Self;
    
    /// Create flat samples (1 per pixel)
    pub fn flat(samples: Vec&lt;T&gt;) -&gt; Self;
    
    /// Check if this is deep data
    pub fn is_deep(&amp;self) -&gt; bool;
    
    /// Total number of samples across all pixels
    pub fn total_sample_count(&amp;self) -&gt; usize;
    
    /// Get sample count for a specific pixel
    pub fn sample_count_at(&amp;self, pixel_index: usize) -&gt; u32;
    
    /// Get samples for a specific pixel
    pub fn samples_at(&amp;self, pixel_index: usize) -&gt; &amp;[T];
    
    /// Iterate over all pixels with their samples
    pub fn iter_pixels(&amp;self) -&gt; impl Iterator&lt;Item = &amp;[T]&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="reading-deep-data"><a class="header" href="#reading-deep-data">Reading Deep Data</a></h2>
<h3 id="using-unifiedreader"><a class="header" href="#using-unifiedreader">Using UnifiedReader</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exrs::prelude::*;

// Read any EXR (flat or deep) with unified API
let image = read()
    .no_deep_data()  // Ignore deep, read flat only
    .all_resolution_levels()
    .all_channels()
    .all_layers()
    .all_attributes()
    .from_file("image.exr")?;
<span class="boring">}</span></code></pre>
<h3 id="reading-deep-channels"><a class="header" href="#reading-deep-channels">Reading Deep Channels</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exrs::prelude::*;
use exrs::image::DeepSamples;

// Custom channel reading with deep support
let image = read()
    .all_resolution_levels()
    .all_channels()
    .all_layers()
    .all_attributes()
    .from_file("deep.exr")?;

// Access deep samples
for layer in &amp;image.layer_data {
    match &amp;layer.channel_data {
        AnyChannels::Deep(channels) =&gt; {
            for channel in channels {
                println!("Channel: {}", channel.name);
                // Process deep samples...
            }
        }
        AnyChannels::Flat(channels) =&gt; {
            // Handle flat data
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="writing-deep-data"><a class="header" href="#writing-deep-data">Writing Deep Data</a></h2>
<h3 id="creating-deep-images"><a class="header" href="#creating-deep-images">Creating Deep Images</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exrs::prelude::*;
use exrs::image::DeepSamples;

// Create sample counts (variable per pixel)
let width = 1920;
let height = 1080;
let mut sample_counts = Vec::with_capacity(width * height);
let mut samples = Vec::new();

for y in 0..height {
    for x in 0..width {
        // Varying sample count per pixel
        let count = if x % 10 == 0 { 3 } else { 1 };
        sample_counts.push(count as u32);
        
        for i in 0..count {
            samples.push(0.5f32 + i as f32 * 0.1);
        }
    }
}

let deep_samples = DeepSamples::deep(sample_counts, samples);
<span class="boring">}</span></code></pre>
<h2 id="deep-data-structure"><a class="header" href="#deep-data-structure">Deep Data Structure</a></h2>
<h3 id="pixel-layout"><a class="header" href="#pixel-layout">Pixel Layout</a></h3>
<pre><code>Pixel (0,0): [sample0, sample1, sample2]  // 3 samples
Pixel (1,0): [sample0]                     // 1 sample
Pixel (2,0): [sample0, sample1]            // 2 samples
...

sample_counts: [3, 1, 2, ...]
samples: [s0_0, s0_1, s0_2, s1_0, s2_0, s2_1, ...]
</code></pre>
<h3 id="memory-layout"><a class="header" href="#memory-layout">Memory Layout</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Accessing pixel samples
let pixel_index = y * width + x;
let start = sample_counts[..pixel_index].iter().sum::&lt;u32&gt;() as usize;
let count = sample_counts[pixel_index] as usize;
let pixel_samples = &amp;samples[start..start + count];
<span class="boring">}</span></code></pre>
<h2 id="block-processing"><a class="header" href="#block-processing">Block Processing</a></h2>
<h3 id="deeptileblock"><a class="header" href="#deeptileblock">DeepTileBlock</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DeepTileBlock {
    /// Tile coordinates
    pub coordinates: TileCoordinates,
    /// Sample counts per pixel in tile
    pub sample_counts: Vec&lt;u32&gt;,
    /// Compressed sample data
    pub compressed_samples: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="deepscanlineblock"><a class="header" href="#deepscanlineblock">DeepScanLineBlock</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DeepScanLineBlock {
    /// Starting Y coordinate
    pub y_coordinate: i32,
    /// Sample counts for scanline range
    pub sample_counts: Vec&lt;u32&gt;,
    /// Compressed sample data
    pub compressed_samples: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre>
<h2 id="compression-for-deep-data-1"><a class="header" href="#compression-for-deep-data-1">Compression for Deep Data</a></h2>
<p>Supported compression methods for deep data:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These work with deep data:
Compression::Uncompressed  // No compression
Compression::RLE           // Run-length encoding
Compression::ZIP1          // ZIP, 1 scanline
Compression::ZIP16         // ZIP, 16 scanlines (recommended)

// These do NOT support deep data:
Compression::PIZ           // Wavelet - flat only
Compression::PXR24         // Lossy - flat only
Compression::B44           // Fixed rate - flat only
Compression::DWAA          // DCT - flat only
<span class="boring">}</span></code></pre>
<h2 id="parallel-processing-2"><a class="header" href="#parallel-processing-2">Parallel Processing</a></h2>
<p>Deep data benefits from parallel decompression:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic parallel processing with rayon
// Each block is decompressed independently

// Performance comparison (4K deep image):
// Sequential: ~2.5s
// Parallel (8 cores): ~1.0s
// Speedup: 2.5x
<span class="boring">}</span></code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="volumetric-data"><a class="header" href="#volumetric-data">Volumetric Data</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Store multiple density samples per pixel
// Front-to-back depth ordering
DeepSamples::deep(
    vec![5, 3, 8, ...],  // Variable samples per ray
    vec![/* density values at each depth */]
)
<span class="boring">}</span></code></pre>
<h3 id="particle-rendering"><a class="header" href="#particle-rendering">Particle Rendering</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Store particle contributions per pixel
// Each particle adds a sample at its depth
DeepSamples::deep(
    sample_counts,  // Particles visible per pixel
    particle_colors // RGBA per particle
)
<span class="boring">}</span></code></pre>
<h3 id="deep-compositing"><a class="header" href="#deep-compositing">Deep Compositing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Non-destructive compositing with depth
// Merge deep images by combining samples
// Sort by depth, composite front-to-back
<span class="boring">}</span></code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Use ZIP16</strong> for deep data compression (best balance)</li>
<li><strong>Pre-allocate</strong> sample vectors when counts are known</li>
<li><strong>Sort samples</strong> by depth for proper compositing</li>
<li><strong>Use parallel reading</strong> for large deep images</li>
<li><strong>Validate sample counts</strong> match expected pixel count</li>
</ol>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use exrs::error::Error;

match read().from_file("deep.exr") {
    Ok(image) =&gt; { /* process */ }
    Err(Error::Invalid(msg)) =&gt; {
        eprintln!("Invalid deep data: {}", msg);
    }
    Err(e) =&gt; {
        eprintln!("Read error: {}", e);
    }
}
<span class="boring">}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
